(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["VueNouislider"] = factory();
	else
		root["VueNouislider"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOlsiZyIsIkZ1bmN0aW9uIiwiZXZhbCIsImUiLCJ3aW5kb3ciLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOztBQUFBLElBQUlBLENBQUo7O0FBRUE7QUFDQUEsSUFBSyxZQUFXO0FBQ2YsUUFBTyxJQUFQO0FBQ0EsQ0FGRyxFQUFKOztBQUlBLElBQUk7QUFDSDtBQUNBQSxLQUFJQSxLQUFLQyxTQUFTLGFBQVQsR0FBTCxJQUFrQyxDQUFDLEdBQUVDLElBQUgsRUFBUyxNQUFULENBQXRDO0FBQ0EsQ0FIRCxDQUdFLE9BQU1DLENBQU4sRUFBUztBQUNWO0FBQ0EsS0FBRyxRQUFPQyxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQXJCLEVBQ0NKLElBQUlJLE1BQUo7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7O0FBRUFDLE9BQU9DLE9BQVAsR0FBaUJOLENBQWpCIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/* styles */\n__webpack_require__(5)\n\nvar Component = __webpack_require__(6)(\n  /* script */\n  __webpack_require__(4),\n  /* template */\n  __webpack_require__(7),\n  /* scopeId */\n  \"data-v-e91d3600\",\n  /* cssModules */\n  null\n)\nComponent.options.__file = \"/Users/besmart/Sites/gitHub/vue-nouislider/src/components/noUiSlider.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key !== \"__esModule\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] noUiSlider.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-e91d3600\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-e91d3600\", Component.options)\n  }\n})()}\n\nmodule.exports = Component.exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9ub1VpU2xpZGVyLnZ1ZT8yOWRjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBLHFCQUF5Tzs7QUFFek87QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGlEQUFpRCxJQUFJO0FBQ3BJLG1DQUFtQzs7QUFFbkM7QUFDQSxZQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyogc3R5bGVzICovXG5yZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XFxcIm9taXRcXFwiOjAsXFxcInJlbW92ZVxcXCI6dHJ1ZX0hY3NzLWxvYWRlciEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi1lOTFkMzYwMFxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hc2Fzcy1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9ub1VpU2xpZGVyLnZ1ZVwiKVxuXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9ub1VpU2xpZGVyLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtZTkxZDM2MDBcXFwifSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vbm9VaVNsaWRlci52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgXCJkYXRhLXYtZTkxZDM2MDBcIixcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIi9Vc2Vycy9iZXNtYXJ0L1NpdGVzL2dpdEh1Yi92dWUtbm91aXNsaWRlci9zcmMvY29tcG9uZW50cy9ub1VpU2xpZGVyLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5ICE9PSBcIl9fZXNNb2R1bGVcIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIG5vVWlTbGlkZXIudnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LWU5MWQzNjAwXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtZTkxZDM2MDBcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMvbm9VaVNsaWRlci52dWVcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_noUiSlider_vue__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_noUiSlider_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_noUiSlider_vue__);\n/* harmony reexport (default from non-hamory) */ __webpack_require__.d(__webpack_exports__, \"noUiSlider\", function() { return __WEBPACK_IMPORTED_MODULE_0__components_noUiSlider_vue___default.a; });\n/* harmony export (immutable) */ __webpack_exports__[\"install\"] = install;\n\n\n// Install the components\nfunction install(Vue) {\n  Vue.component('nouislider', __WEBPACK_IMPORTED_MODULE_0__components_noUiSlider_vue___default.a);\n  /* -- Add more components here -- */\n}\n\n// Expose the components\n\n\n/* -- Plugin definition & Auto-install -- */\n/* You shouldn't have to modify the code below */\n\n// Plugin\nvar plugin = {\n  /* eslint-disable no-undef */\n  version: \"1.0.0\",\n  install: install\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (plugin);\n\n// Auto-install\nvar GlobalVue = null;\nif (typeof window !== 'undefined') {\n  GlobalVue = window.Vue;\n} else if (typeof global !== 'undefined') {\n  GlobalVue = global.Vue;\n}\nif (GlobalVue) {\n  GlobalVue.use(plugin);\n}\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/OTU1MiJdLCJuYW1lcyI6WyJpbnN0YWxsIiwiVnVlIiwiY29tcG9uZW50IiwicGx1Z2luIiwidmVyc2lvbiIsIkdsb2JhbFZ1ZSIsIndpbmRvdyIsImdsb2JhbCIsInVzZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7QUFFQTtBQUNPLFNBQVNBLE9BQVQsQ0FBa0JDLEdBQWxCLEVBQXVCO0FBQzVCQSxNQUFJQyxTQUFKLENBQWMsWUFBZCxFQUE0QixrRUFBNUI7QUFDQTtBQUNEOztBQUVEO0FBQ0E7O0FBS0E7QUFDQTs7QUFFQTtBQUNBLElBQU1DLFNBQVM7QUFDYjtBQUNBQyxXQUFTLE9BRkk7QUFHYko7QUFIYSxDQUFmOztBQU1BLCtEQUFlRyxNQUFmOztBQUVBO0FBQ0EsSUFBSUUsWUFBWSxJQUFoQjtBQUNBLElBQUksT0FBT0MsTUFBUCxLQUFrQixXQUF0QixFQUFtQztBQUNqQ0QsY0FBWUMsT0FBT0wsR0FBbkI7QUFDRCxDQUZELE1BRU8sSUFBSSxPQUFPTSxNQUFQLEtBQWtCLFdBQXRCLEVBQW1DO0FBQ3hDRixjQUFZRSxPQUFPTixHQUFuQjtBQUNEO0FBQ0QsSUFBSUksU0FBSixFQUFlO0FBQ2JBLFlBQVVHLEdBQVYsQ0FBY0wsTUFBZDtBQUNELEMiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBub1VpU2xpZGVyIGZyb20gJy4vY29tcG9uZW50cy9ub1VpU2xpZGVyLnZ1ZSdcblxuLy8gSW5zdGFsbCB0aGUgY29tcG9uZW50c1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwgKFZ1ZSkge1xuICBWdWUuY29tcG9uZW50KCdub3Vpc2xpZGVyJywgbm9VaVNsaWRlcilcbiAgLyogLS0gQWRkIG1vcmUgY29tcG9uZW50cyBoZXJlIC0tICovXG59XG5cbi8vIEV4cG9zZSB0aGUgY29tcG9uZW50c1xuZXhwb3J0IHtcbiAgbm9VaVNsaWRlcixcbiAgLyogLS0gQWRkIG1vcmUgY29tcG9uZW50cyBoZXJlIC0tICovXG59XG5cbi8qIC0tIFBsdWdpbiBkZWZpbml0aW9uICYgQXV0by1pbnN0YWxsIC0tICovXG4vKiBZb3Ugc2hvdWxkbid0IGhhdmUgdG8gbW9kaWZ5IHRoZSBjb2RlIGJlbG93ICovXG5cbi8vIFBsdWdpblxuY29uc3QgcGx1Z2luID0ge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuICB2ZXJzaW9uOiBWRVJTSU9OLFxuICBpbnN0YWxsLFxufVxuXG5leHBvcnQgZGVmYXVsdCBwbHVnaW5cblxuLy8gQXV0by1pbnN0YWxsXG5sZXQgR2xvYmFsVnVlID0gbnVsbFxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIEdsb2JhbFZ1ZSA9IHdpbmRvdy5WdWVcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgR2xvYmFsVnVlID0gZ2xvYmFsLlZ1ZVxufVxuaWYgKEdsb2JhbFZ1ZSkge1xuICBHbG9iYWxWdWUudXNlKHBsdWdpbilcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*! nouislider - 9.2.0 - 2017-01-11 10:35:34 */\n\n(function (factory) {\n\n\tif (true) {\n\n\t\t// AMD. Register as an anonymous module.\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {\n\n\t\t// Node/CommonJS\n\t\tmodule.exports = factory();\n\t} else {\n\n\t\t// Browser globals\n\t\twindow.noUiSlider = factory();\n\t}\n})(function () {\n\n\t'use strict';\n\n\tvar VERSION = '9.2.0';\n\n\t// Creates a node, adds it to target, returns the new node.\n\tfunction addNodeTo(target, className) {\n\t\tvar div = document.createElement('div');\n\t\taddClass(div, className);\n\t\ttarget.appendChild(div);\n\t\treturn div;\n\t}\n\n\t// Removes duplicates from an array.\n\tfunction unique(array) {\n\t\treturn array.filter(function (a) {\n\t\t\treturn !this[a] ? this[a] = true : false;\n\t\t}, {});\n\t}\n\n\t// Round a value to the closest 'to'.\n\tfunction closest(value, to) {\n\t\treturn Math.round(value / to) * to;\n\t}\n\n\t// Current position of an element relative to the document.\n\tfunction offset(elem, orientation) {\n\n\t\tvar rect = elem.getBoundingClientRect(),\n\t\t    doc = elem.ownerDocument,\n\t\t    docElem = doc.documentElement,\n\t\t    pageOffset = getPageOffset();\n\n\t\t// getBoundingClientRect contains left scroll in Chrome on Android.\n\t\t// I haven't found a feature detection that proves this. Worst case\n\t\t// scenario on mis-match: the 'tap' feature on horizontal sliders breaks.\n\t\tif (/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)) {\n\t\t\tpageOffset.x = 0;\n\t\t}\n\n\t\treturn orientation ? rect.top + pageOffset.y - docElem.clientTop : rect.left + pageOffset.x - docElem.clientLeft;\n\t}\n\n\t// Checks whether a value is numerical.\n\tfunction isNumeric(a) {\n\t\treturn typeof a === 'number' && !isNaN(a) && isFinite(a);\n\t}\n\n\t// Sets a class and removes it after [duration] ms.\n\tfunction addClassFor(element, className, duration) {\n\t\tif (duration > 0) {\n\t\t\taddClass(element, className);\n\t\t\tsetTimeout(function () {\n\t\t\t\tremoveClass(element, className);\n\t\t\t}, duration);\n\t\t}\n\t}\n\n\t// Limits a value to 0 - 100\n\tfunction limit(a) {\n\t\treturn Math.max(Math.min(a, 100), 0);\n\t}\n\n\t// Wraps a variable as an array, if it isn't one yet.\n\t// Note that an input array is returned by reference!\n\tfunction asArray(a) {\n\t\treturn Array.isArray(a) ? a : [a];\n\t}\n\n\t// Counts decimals\n\tfunction countDecimals(numStr) {\n\t\tnumStr = String(numStr);\n\t\tvar pieces = numStr.split(\".\");\n\t\treturn pieces.length > 1 ? pieces[1].length : 0;\n\t}\n\n\t// http://youmightnotneedjquery.com/#add_class\n\tfunction addClass(el, className) {\n\t\tif (el.classList) {\n\t\t\tel.classList.add(className);\n\t\t} else {\n\t\t\tel.className += ' ' + className;\n\t\t}\n\t}\n\n\t// http://youmightnotneedjquery.com/#remove_class\n\tfunction removeClass(el, className) {\n\t\tif (el.classList) {\n\t\t\tel.classList.remove(className);\n\t\t} else {\n\t\t\tel.className = el.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\n\t\t}\n\t}\n\n\t// https://plainjs.com/javascript/attributes/adding-removing-and-testing-for-classes-9/\n\tfunction hasClass(el, className) {\n\t\treturn el.classList ? el.classList.contains(className) : new RegExp('\\\\b' + className + '\\\\b').test(el.className);\n\t}\n\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY#Notes\n\tfunction getPageOffset() {\n\n\t\tvar supportPageOffset = window.pageXOffset !== undefined,\n\t\t    isCSS1Compat = (document.compatMode || \"\") === \"CSS1Compat\",\n\t\t    x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? document.documentElement.scrollLeft : document.body.scrollLeft,\n\t\t    y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop;\n\n\t\treturn {\n\t\t\tx: x,\n\t\t\ty: y\n\t\t};\n\t}\n\n\t// we provide a function to compute constants instead\n\t// of accessing window.* as soon as the module needs it\n\t// so that we do not compute anything if not needed\n\tfunction getActions() {\n\n\t\t// Determine the events to bind. IE11 implements pointerEvents without\n\t\t// a prefix, which breaks compatibility with the IE10 implementation.\n\t\treturn window.navigator.pointerEnabled ? {\n\t\t\tstart: 'pointerdown',\n\t\t\tmove: 'pointermove',\n\t\t\tend: 'pointerup'\n\t\t} : window.navigator.msPointerEnabled ? {\n\t\t\tstart: 'MSPointerDown',\n\t\t\tmove: 'MSPointerMove',\n\t\t\tend: 'MSPointerUp'\n\t\t} : {\n\t\t\tstart: 'mousedown touchstart',\n\t\t\tmove: 'mousemove touchmove',\n\t\t\tend: 'mouseup touchend'\n\t\t};\n\t}\n\n\t// Value calculation\n\n\t// Determine the size of a sub-range in relation to a full range.\n\tfunction subRangeRatio(pa, pb) {\n\t\treturn 100 / (pb - pa);\n\t}\n\n\t// (percentage) How many percent is this value of this range?\n\tfunction fromPercentage(range, value) {\n\t\treturn value * 100 / (range[1] - range[0]);\n\t}\n\n\t// (percentage) Where is this value on this range?\n\tfunction toPercentage(range, value) {\n\t\treturn fromPercentage(range, range[0] < 0 ? value + Math.abs(range[0]) : value - range[0]);\n\t}\n\n\t// (value) How much is this percentage on this range?\n\tfunction isPercentage(range, value) {\n\t\treturn value * (range[1] - range[0]) / 100 + range[0];\n\t}\n\n\t// Range conversion\n\n\tfunction getJ(value, arr) {\n\n\t\tvar j = 1;\n\n\t\twhile (value >= arr[j]) {\n\t\t\tj += 1;\n\t\t}\n\n\t\treturn j;\n\t}\n\n\t// (percentage) Input a value, find where, on a scale of 0-100, it applies.\n\tfunction toStepping(xVal, xPct, value) {\n\n\t\tif (value >= xVal.slice(-1)[0]) {\n\t\t\treturn 100;\n\t\t}\n\n\t\tvar j = getJ(value, xVal),\n\t\t    va,\n\t\t    vb,\n\t\t    pa,\n\t\t    pb;\n\n\t\tva = xVal[j - 1];\n\t\tvb = xVal[j];\n\t\tpa = xPct[j - 1];\n\t\tpb = xPct[j];\n\n\t\treturn pa + toPercentage([va, vb], value) / subRangeRatio(pa, pb);\n\t}\n\n\t// (value) Input a percentage, find where it is on the specified range.\n\tfunction fromStepping(xVal, xPct, value) {\n\n\t\t// There is no range group that fits 100\n\t\tif (value >= 100) {\n\t\t\treturn xVal.slice(-1)[0];\n\t\t}\n\n\t\tvar j = getJ(value, xPct),\n\t\t    va,\n\t\t    vb,\n\t\t    pa,\n\t\t    pb;\n\n\t\tva = xVal[j - 1];\n\t\tvb = xVal[j];\n\t\tpa = xPct[j - 1];\n\t\tpb = xPct[j];\n\n\t\treturn isPercentage([va, vb], (value - pa) * subRangeRatio(pa, pb));\n\t}\n\n\t// (percentage) Get the step that applies at a certain value.\n\tfunction getStep(xPct, xSteps, snap, value) {\n\n\t\tif (value === 100) {\n\t\t\treturn value;\n\t\t}\n\n\t\tvar j = getJ(value, xPct),\n\t\t    a,\n\t\t    b;\n\n\t\t// If 'snap' is set, steps are used as fixed points on the slider.\n\t\tif (snap) {\n\n\t\t\ta = xPct[j - 1];\n\t\t\tb = xPct[j];\n\n\t\t\t// Find the closest position, a or b.\n\t\t\tif (value - a > (b - a) / 2) {\n\t\t\t\treturn b;\n\t\t\t}\n\n\t\t\treturn a;\n\t\t}\n\n\t\tif (!xSteps[j - 1]) {\n\t\t\treturn value;\n\t\t}\n\n\t\treturn xPct[j - 1] + closest(value - xPct[j - 1], xSteps[j - 1]);\n\t}\n\n\t// Entry parsing\n\n\tfunction handleEntryPoint(index, value, that) {\n\n\t\tvar percentage;\n\n\t\t// Wrap numerical input in an array.\n\t\tif (typeof value === \"number\") {\n\t\t\tvalue = [value];\n\t\t}\n\n\t\t// Reject any invalid input, by testing whether value is an array.\n\t\tif (Object.prototype.toString.call(value) !== '[object Array]') {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'range' contains invalid value.\");\n\t\t}\n\n\t\t// Covert min/max syntax to 0 and 100.\n\t\tif (index === 'min') {\n\t\t\tpercentage = 0;\n\t\t} else if (index === 'max') {\n\t\t\tpercentage = 100;\n\t\t} else {\n\t\t\tpercentage = parseFloat(index);\n\t\t}\n\n\t\t// Check for correct input.\n\t\tif (!isNumeric(percentage) || !isNumeric(value[0])) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'range' value isn't numeric.\");\n\t\t}\n\n\t\t// Store values.\n\t\tthat.xPct.push(percentage);\n\t\tthat.xVal.push(value[0]);\n\n\t\t// NaN will evaluate to false too, but to keep\n\t\t// logging clear, set step explicitly. Make sure\n\t\t// not to override the 'step' setting with false.\n\t\tif (!percentage) {\n\t\t\tif (!isNaN(value[1])) {\n\t\t\t\tthat.xSteps[0] = value[1];\n\t\t\t}\n\t\t} else {\n\t\t\tthat.xSteps.push(isNaN(value[1]) ? false : value[1]);\n\t\t}\n\n\t\tthat.xHighestCompleteStep.push(0);\n\t}\n\n\tfunction handleStepPoint(i, n, that) {\n\n\t\t// Ignore 'false' stepping.\n\t\tif (!n) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Factor to range ratio\n\t\tthat.xSteps[i] = fromPercentage([that.xVal[i], that.xVal[i + 1]], n) / subRangeRatio(that.xPct[i], that.xPct[i + 1]);\n\n\t\tvar totalSteps = (that.xVal[i + 1] - that.xVal[i]) / that.xNumSteps[i];\n\t\tvar highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);\n\t\tvar step = that.xVal[i] + that.xNumSteps[i] * highestStep;\n\n\t\tthat.xHighestCompleteStep[i] = step;\n\t}\n\n\t// Interface\n\n\t// The interface to Spectrum handles all direction-based\n\t// conversions, so the above values are unaware.\n\n\tfunction Spectrum(entry, snap, direction, singleStep) {\n\n\t\tthis.xPct = [];\n\t\tthis.xVal = [];\n\t\tthis.xSteps = [singleStep || false];\n\t\tthis.xNumSteps = [false];\n\t\tthis.xHighestCompleteStep = [];\n\n\t\tthis.snap = snap;\n\t\tthis.direction = direction;\n\n\t\tvar index,\n\t\t    ordered = [/* [0, 'min'], [1, '50%'], [2, 'max'] */];\n\n\t\t// Map the object keys to an array.\n\t\tfor (index in entry) {\n\t\t\tif (entry.hasOwnProperty(index)) {\n\t\t\t\tordered.push([entry[index], index]);\n\t\t\t}\n\t\t}\n\n\t\t// Sort all entries by value (numeric sort).\n\t\tif (ordered.length && _typeof(ordered[0][0]) === \"object\") {\n\t\t\tordered.sort(function (a, b) {\n\t\t\t\treturn a[0][0] - b[0][0];\n\t\t\t});\n\t\t} else {\n\t\t\tordered.sort(function (a, b) {\n\t\t\t\treturn a[0] - b[0];\n\t\t\t});\n\t\t}\n\n\t\t// Convert all entries to subranges.\n\t\tfor (index = 0; index < ordered.length; index++) {\n\t\t\thandleEntryPoint(ordered[index][1], ordered[index][0], this);\n\t\t}\n\n\t\t// Store the actual step values.\n\t\t// xSteps is sorted in the same order as xPct and xVal.\n\t\tthis.xNumSteps = this.xSteps.slice(0);\n\n\t\t// Convert all numeric steps to the percentage of the subrange they represent.\n\t\tfor (index = 0; index < this.xNumSteps.length; index++) {\n\t\t\thandleStepPoint(index, this.xNumSteps[index], this);\n\t\t}\n\t}\n\n\tSpectrum.prototype.getMargin = function (value) {\n\n\t\tvar step = this.xNumSteps[0];\n\n\t\tif (step && value / step % 1 !== 0) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'limit', 'margin' and 'padding' must be divisible by step.\");\n\t\t}\n\n\t\treturn this.xPct.length === 2 ? fromPercentage(this.xVal, value) : false;\n\t};\n\n\tSpectrum.prototype.toStepping = function (value) {\n\n\t\tvalue = toStepping(this.xVal, this.xPct, value);\n\n\t\treturn value;\n\t};\n\n\tSpectrum.prototype.fromStepping = function (value) {\n\n\t\treturn fromStepping(this.xVal, this.xPct, value);\n\t};\n\n\tSpectrum.prototype.getStep = function (value) {\n\n\t\tvalue = getStep(this.xPct, this.xSteps, this.snap, value);\n\n\t\treturn value;\n\t};\n\n\tSpectrum.prototype.getNearbySteps = function (value) {\n\n\t\tvar j = getJ(value, this.xPct);\n\n\t\treturn {\n\t\t\tstepBefore: { startValue: this.xVal[j - 2], step: this.xNumSteps[j - 2], highestStep: this.xHighestCompleteStep[j - 2] },\n\t\t\tthisStep: { startValue: this.xVal[j - 1], step: this.xNumSteps[j - 1], highestStep: this.xHighestCompleteStep[j - 1] },\n\t\t\tstepAfter: { startValue: this.xVal[j - 0], step: this.xNumSteps[j - 0], highestStep: this.xHighestCompleteStep[j - 0] }\n\t\t};\n\t};\n\n\tSpectrum.prototype.countStepDecimals = function () {\n\t\tvar stepDecimals = this.xNumSteps.map(countDecimals);\n\t\treturn Math.max.apply(null, stepDecimals);\n\t};\n\n\t// Outside testing\n\tSpectrum.prototype.convert = function (value) {\n\t\treturn this.getStep(this.toStepping(value));\n\t};\n\n\t/*\tEvery input option is tested and parsed. This'll prevent\r\n \tendless validation in internal methods. These tests are\r\n \tstructured with an item for every option available. An\r\n \toption can be marked as required by setting the 'r' flag.\r\n \tThe testing function is provided with three arguments:\r\n \t\t- The provided value for the option;\r\n \t\t- A reference to the options object;\r\n \t\t- The name for the option;\r\n \r\n \tThe testing function returns false when an error is detected,\r\n \tor true when everything is OK. It can also modify the option\r\n \tobject, to make sure all values can be correctly looped elsewhere. */\n\n\tvar defaultFormatter = { 'to': function to(value) {\n\t\t\treturn value !== undefined && value.toFixed(2);\n\t\t}, 'from': Number };\n\n\tfunction testStep(parsed, entry) {\n\n\t\tif (!isNumeric(entry)) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'step' is not numeric.\");\n\t\t}\n\n\t\t// The step option can still be used to set stepping\n\t\t// for linear sliders. Overwritten if set in 'range'.\n\t\tparsed.singleStep = entry;\n\t}\n\n\tfunction testRange(parsed, entry) {\n\n\t\t// Filter incorrect input.\n\t\tif ((typeof entry === 'undefined' ? 'undefined' : _typeof(entry)) !== 'object' || Array.isArray(entry)) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'range' is not an object.\");\n\t\t}\n\n\t\t// Catch missing start or end.\n\t\tif (entry.min === undefined || entry.max === undefined) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): Missing 'min' or 'max' in 'range'.\");\n\t\t}\n\n\t\t// Catch equal start or end.\n\t\tif (entry.min === entry.max) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'range' 'min' and 'max' cannot be equal.\");\n\t\t}\n\n\t\tparsed.spectrum = new Spectrum(entry, parsed.snap, parsed.dir, parsed.singleStep);\n\t}\n\n\tfunction testStart(parsed, entry) {\n\n\t\tentry = asArray(entry);\n\n\t\t// Validate input. Values aren't tested, as the public .val method\n\t\t// will always provide a valid location.\n\t\tif (!Array.isArray(entry) || !entry.length) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'start' option is incorrect.\");\n\t\t}\n\n\t\t// Store the number of handles.\n\t\tparsed.handles = entry.length;\n\n\t\t// When the slider is initialized, the .val method will\n\t\t// be called with the start options.\n\t\tparsed.start = entry;\n\t}\n\n\tfunction testSnap(parsed, entry) {\n\n\t\t// Enforce 100% stepping within subranges.\n\t\tparsed.snap = entry;\n\n\t\tif (typeof entry !== 'boolean') {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'snap' option must be a boolean.\");\n\t\t}\n\t}\n\n\tfunction testAnimate(parsed, entry) {\n\n\t\t// Enforce 100% stepping within subranges.\n\t\tparsed.animate = entry;\n\n\t\tif (typeof entry !== 'boolean') {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'animate' option must be a boolean.\");\n\t\t}\n\t}\n\n\tfunction testAnimationDuration(parsed, entry) {\n\n\t\tparsed.animationDuration = entry;\n\n\t\tif (typeof entry !== 'number') {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'animationDuration' option must be a number.\");\n\t\t}\n\t}\n\n\tfunction testConnect(parsed, entry) {\n\n\t\tvar connect = [false];\n\t\tvar i;\n\n\t\t// Map legacy options\n\t\tif (entry === 'lower') {\n\t\t\tentry = [true, false];\n\t\t} else if (entry === 'upper') {\n\t\t\tentry = [false, true];\n\t\t}\n\n\t\t// Handle boolean options\n\t\tif (entry === true || entry === false) {\n\n\t\t\tfor (i = 1; i < parsed.handles; i++) {\n\t\t\t\tconnect.push(entry);\n\t\t\t}\n\n\t\t\tconnect.push(false);\n\t\t}\n\n\t\t// Reject invalid input\n\t\telse if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1) {\n\t\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'connect' option doesn't match handle count.\");\n\t\t\t} else {\n\t\t\t\tconnect = entry;\n\t\t\t}\n\n\t\tparsed.connect = connect;\n\t}\n\n\tfunction testOrientation(parsed, entry) {\n\n\t\t// Set orientation to an a numerical value for easy\n\t\t// array selection.\n\t\tswitch (entry) {\n\t\t\tcase 'horizontal':\n\t\t\t\tparsed.ort = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'vertical':\n\t\t\t\tparsed.ort = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'orientation' option is invalid.\");\n\t\t}\n\t}\n\n\tfunction testMargin(parsed, entry) {\n\n\t\tif (!isNumeric(entry)) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'margin' option must be numeric.\");\n\t\t}\n\n\t\t// Issue #582\n\t\tif (entry === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tparsed.margin = parsed.spectrum.getMargin(entry);\n\n\t\tif (!parsed.margin) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'margin' option is only supported on linear sliders.\");\n\t\t}\n\t}\n\n\tfunction testLimit(parsed, entry) {\n\n\t\tif (!isNumeric(entry)) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'limit' option must be numeric.\");\n\t\t}\n\n\t\tparsed.limit = parsed.spectrum.getMargin(entry);\n\n\t\tif (!parsed.limit || parsed.handles < 2) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'limit' option is only supported on linear sliders with 2 or more handles.\");\n\t\t}\n\t}\n\n\tfunction testPadding(parsed, entry) {\n\n\t\tif (!isNumeric(entry)) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'padding' option must be numeric.\");\n\t\t}\n\n\t\tif (entry === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tparsed.padding = parsed.spectrum.getMargin(entry);\n\n\t\tif (!parsed.padding) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'padding' option is only supported on linear sliders.\");\n\t\t}\n\n\t\tif (parsed.padding < 0) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'padding' option must be a positive number.\");\n\t\t}\n\n\t\tif (parsed.padding >= 50) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'padding' option must be less than half the range.\");\n\t\t}\n\t}\n\n\tfunction testDirection(parsed, entry) {\n\n\t\t// Set direction as a numerical value for easy parsing.\n\t\t// Invert connection for RTL sliders, so that the proper\n\t\t// handles get the connect/background classes.\n\t\tswitch (entry) {\n\t\t\tcase 'ltr':\n\t\t\t\tparsed.dir = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'rtl':\n\t\t\t\tparsed.dir = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'direction' option was not recognized.\");\n\t\t}\n\t}\n\n\tfunction testBehaviour(parsed, entry) {\n\n\t\t// Make sure the input is a string.\n\t\tif (typeof entry !== 'string') {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'behaviour' must be a string containing options.\");\n\t\t}\n\n\t\t// Check if the string contains any keywords.\n\t\t// None are required.\n\t\tvar tap = entry.indexOf('tap') >= 0;\n\t\tvar drag = entry.indexOf('drag') >= 0;\n\t\tvar fixed = entry.indexOf('fixed') >= 0;\n\t\tvar snap = entry.indexOf('snap') >= 0;\n\t\tvar hover = entry.indexOf('hover') >= 0;\n\n\t\tif (fixed) {\n\n\t\t\tif (parsed.handles !== 2) {\n\t\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'fixed' behaviour must be used with 2 handles\");\n\t\t\t}\n\n\t\t\t// Use margin to enforce fixed state\n\t\t\ttestMargin(parsed, parsed.start[1] - parsed.start[0]);\n\t\t}\n\n\t\tparsed.events = {\n\t\t\ttap: tap || snap,\n\t\t\tdrag: drag,\n\t\t\tfixed: fixed,\n\t\t\tsnap: snap,\n\t\t\thover: hover\n\t\t};\n\t}\n\n\tfunction testTooltips(parsed, entry) {\n\n\t\tif (entry === false) {\n\t\t\treturn;\n\t\t} else if (entry === true) {\n\n\t\t\tparsed.tooltips = [];\n\n\t\t\tfor (var i = 0; i < parsed.handles; i++) {\n\t\t\t\tparsed.tooltips.push(true);\n\t\t\t}\n\t\t} else {\n\n\t\t\tparsed.tooltips = asArray(entry);\n\n\t\t\tif (parsed.tooltips.length !== parsed.handles) {\n\t\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): must pass a formatter for all handles.\");\n\t\t\t}\n\n\t\t\tparsed.tooltips.forEach(function (formatter) {\n\t\t\t\tif (typeof formatter !== 'boolean' && ((typeof formatter === 'undefined' ? 'undefined' : _typeof(formatter)) !== 'object' || typeof formatter.to !== 'function')) {\n\t\t\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'tooltips' must be passed a formatter or 'false'.\");\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction testFormat(parsed, entry) {\n\n\t\tparsed.format = entry;\n\n\t\t// Any object with a to and from method is supported.\n\t\tif (typeof entry.to === 'function' && typeof entry.from === 'function') {\n\t\t\treturn true;\n\t\t}\n\n\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'format' requires 'to' and 'from' methods.\");\n\t}\n\n\tfunction testCssPrefix(parsed, entry) {\n\n\t\tif (entry !== undefined && typeof entry !== 'string' && entry !== false) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'cssPrefix' must be a string or `false`.\");\n\t\t}\n\n\t\tparsed.cssPrefix = entry;\n\t}\n\n\tfunction testCssClasses(parsed, entry) {\n\n\t\tif (entry !== undefined && (typeof entry === 'undefined' ? 'undefined' : _typeof(entry)) !== 'object') {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'cssClasses' must be an object.\");\n\t\t}\n\n\t\tif (typeof parsed.cssPrefix === 'string') {\n\t\t\tparsed.cssClasses = {};\n\n\t\t\tfor (var key in entry) {\n\t\t\t\tif (!entry.hasOwnProperty(key)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tparsed.cssClasses[key] = parsed.cssPrefix + entry[key];\n\t\t\t}\n\t\t} else {\n\t\t\tparsed.cssClasses = entry;\n\t\t}\n\t}\n\n\tfunction testUseRaf(parsed, entry) {\n\t\tif (entry === true || entry === false) {\n\t\t\tparsed.useRequestAnimationFrame = entry;\n\t\t} else {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'useRequestAnimationFrame' option should be true (default) or false.\");\n\t\t}\n\t}\n\n\t// Test all developer settings and parse to assumption-safe values.\n\tfunction testOptions(options) {\n\n\t\t// To prove a fix for #537, freeze options here.\n\t\t// If the object is modified, an error will be thrown.\n\t\t// Object.freeze(options);\n\n\t\tvar parsed = {\n\t\t\tmargin: 0,\n\t\t\tlimit: 0,\n\t\t\tpadding: 0,\n\t\t\tanimate: true,\n\t\t\tanimationDuration: 300,\n\t\t\tformat: defaultFormatter\n\t\t};\n\n\t\t// Tests are executed in the order they are presented here.\n\t\tvar tests = {\n\t\t\t'step': { r: false, t: testStep },\n\t\t\t'start': { r: true, t: testStart },\n\t\t\t'connect': { r: true, t: testConnect },\n\t\t\t'direction': { r: true, t: testDirection },\n\t\t\t'snap': { r: false, t: testSnap },\n\t\t\t'animate': { r: false, t: testAnimate },\n\t\t\t'animationDuration': { r: false, t: testAnimationDuration },\n\t\t\t'range': { r: true, t: testRange },\n\t\t\t'orientation': { r: false, t: testOrientation },\n\t\t\t'margin': { r: false, t: testMargin },\n\t\t\t'limit': { r: false, t: testLimit },\n\t\t\t'padding': { r: false, t: testPadding },\n\t\t\t'behaviour': { r: true, t: testBehaviour },\n\t\t\t'format': { r: false, t: testFormat },\n\t\t\t'tooltips': { r: false, t: testTooltips },\n\t\t\t'cssPrefix': { r: false, t: testCssPrefix },\n\t\t\t'cssClasses': { r: false, t: testCssClasses },\n\t\t\t'useRequestAnimationFrame': { r: false, t: testUseRaf }\n\t\t};\n\n\t\tvar defaults = {\n\t\t\t'connect': false,\n\t\t\t'direction': 'ltr',\n\t\t\t'behaviour': 'tap',\n\t\t\t'orientation': 'horizontal',\n\t\t\t'cssPrefix': 'noUi-',\n\t\t\t'cssClasses': {\n\t\t\t\ttarget: 'target',\n\t\t\t\tbase: 'base',\n\t\t\t\torigin: 'origin',\n\t\t\t\thandle: 'handle',\n\t\t\t\thandleLower: 'handle-lower',\n\t\t\t\thandleUpper: 'handle-upper',\n\t\t\t\thorizontal: 'horizontal',\n\t\t\t\tvertical: 'vertical',\n\t\t\t\tbackground: 'background',\n\t\t\t\tconnect: 'connect',\n\t\t\t\tltr: 'ltr',\n\t\t\t\trtl: 'rtl',\n\t\t\t\tdraggable: 'draggable',\n\t\t\t\tdrag: 'state-drag',\n\t\t\t\ttap: 'state-tap',\n\t\t\t\tactive: 'active',\n\t\t\t\ttooltip: 'tooltip',\n\t\t\t\tpips: 'pips',\n\t\t\t\tpipsHorizontal: 'pips-horizontal',\n\t\t\t\tpipsVertical: 'pips-vertical',\n\t\t\t\tmarker: 'marker',\n\t\t\t\tmarkerHorizontal: 'marker-horizontal',\n\t\t\t\tmarkerVertical: 'marker-vertical',\n\t\t\t\tmarkerNormal: 'marker-normal',\n\t\t\t\tmarkerLarge: 'marker-large',\n\t\t\t\tmarkerSub: 'marker-sub',\n\t\t\t\tvalue: 'value',\n\t\t\t\tvalueHorizontal: 'value-horizontal',\n\t\t\t\tvalueVertical: 'value-vertical',\n\t\t\t\tvalueNormal: 'value-normal',\n\t\t\t\tvalueLarge: 'value-large',\n\t\t\t\tvalueSub: 'value-sub'\n\t\t\t},\n\t\t\t'useRequestAnimationFrame': true\n\t\t};\n\n\t\t// Run all options through a testing mechanism to ensure correct\n\t\t// input. It should be noted that options might get modified to\n\t\t// be handled properly. E.g. wrapping integers in arrays.\n\t\tObject.keys(tests).forEach(function (name) {\n\n\t\t\t// If the option isn't set, but it is required, throw an error.\n\t\t\tif (options[name] === undefined && defaults[name] === undefined) {\n\n\t\t\t\tif (tests[name].r) {\n\t\t\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): '\" + name + \"' is required.\");\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\ttests[name].t(parsed, options[name] === undefined ? defaults[name] : options[name]);\n\t\t});\n\n\t\t// Forward pips options\n\t\tparsed.pips = options.pips;\n\n\t\tvar styles = [['left', 'top'], ['right', 'bottom']];\n\n\t\t// Pre-define the styles.\n\t\tparsed.style = styles[parsed.dir][parsed.ort];\n\t\tparsed.styleOposite = styles[parsed.dir ? 0 : 1][parsed.ort];\n\n\t\treturn parsed;\n\t}\n\n\tfunction closure(target, options, originalOptions) {\n\n\t\tvar actions = getActions();\n\n\t\t// All variables local to 'closure' are prefixed with 'scope_'\n\t\tvar scope_Target = target;\n\t\tvar scope_Locations = [];\n\t\tvar scope_Base;\n\t\tvar scope_Handles;\n\t\tvar scope_HandleNumbers = [];\n\t\tvar scope_ActiveHandle = false;\n\t\tvar scope_Connects;\n\t\tvar scope_Spectrum = options.spectrum;\n\t\tvar scope_Values = [];\n\t\tvar scope_Events = {};\n\t\tvar scope_Self;\n\n\t\t// Append a origin to the base\n\t\tfunction addOrigin(base, handleNumber) {\n\n\t\t\tvar origin = addNodeTo(base, options.cssClasses.origin);\n\t\t\tvar handle = addNodeTo(origin, options.cssClasses.handle);\n\n\t\t\thandle.setAttribute('data-handle', handleNumber);\n\n\t\t\tif (handleNumber === 0) {\n\t\t\t\taddClass(handle, options.cssClasses.handleLower);\n\t\t\t} else if (handleNumber === options.handles - 1) {\n\t\t\t\taddClass(handle, options.cssClasses.handleUpper);\n\t\t\t}\n\n\t\t\treturn origin;\n\t\t}\n\n\t\t// Insert nodes for connect elements\n\t\tfunction addConnect(base, add) {\n\n\t\t\tif (!add) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn addNodeTo(base, options.cssClasses.connect);\n\t\t}\n\n\t\t// Add handles to the slider base.\n\t\tfunction addElements(connectOptions, base) {\n\n\t\t\tscope_Handles = [];\n\t\t\tscope_Connects = [];\n\n\t\t\tscope_Connects.push(addConnect(base, connectOptions[0]));\n\n\t\t\t// [::::O====O====O====]\n\t\t\t// connectOptions = [0, 1, 1, 1]\n\n\t\t\tfor (var i = 0; i < options.handles; i++) {\n\t\t\t\t// Keep a list of all added handles.\n\t\t\t\tscope_Handles.push(addOrigin(base, i));\n\t\t\t\tscope_HandleNumbers[i] = i;\n\t\t\t\tscope_Connects.push(addConnect(base, connectOptions[i + 1]));\n\t\t\t}\n\t\t}\n\n\t\t// Initialize a single slider.\n\t\tfunction addSlider(target) {\n\n\t\t\t// Apply classes and data to the target.\n\t\t\taddClass(target, options.cssClasses.target);\n\n\t\t\tif (options.dir === 0) {\n\t\t\t\taddClass(target, options.cssClasses.ltr);\n\t\t\t} else {\n\t\t\t\taddClass(target, options.cssClasses.rtl);\n\t\t\t}\n\n\t\t\tif (options.ort === 0) {\n\t\t\t\taddClass(target, options.cssClasses.horizontal);\n\t\t\t} else {\n\t\t\t\taddClass(target, options.cssClasses.vertical);\n\t\t\t}\n\n\t\t\tscope_Base = addNodeTo(target, options.cssClasses.base);\n\t\t}\n\n\t\tfunction addTooltip(handle, handleNumber) {\n\n\t\t\tif (!options.tooltips[handleNumber]) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn addNodeTo(handle.firstChild, options.cssClasses.tooltip);\n\t\t}\n\n\t\t// The tooltips option is a shorthand for using the 'update' event.\n\t\tfunction tooltips() {\n\n\t\t\t// Tooltips are added with options.tooltips in original order.\n\t\t\tvar tips = scope_Handles.map(addTooltip);\n\n\t\t\tbindEvent('update', function (values, handleNumber, unencoded) {\n\n\t\t\t\tif (!tips[handleNumber]) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar formattedValue = values[handleNumber];\n\n\t\t\t\tif (options.tooltips[handleNumber] !== true) {\n\t\t\t\t\tformattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);\n\t\t\t\t}\n\n\t\t\t\ttips[handleNumber].innerHTML = formattedValue;\n\t\t\t});\n\t\t}\n\n\t\tfunction getGroup(mode, values, stepped) {\n\n\t\t\t// Use the range.\n\t\t\tif (mode === 'range' || mode === 'steps') {\n\t\t\t\treturn scope_Spectrum.xVal;\n\t\t\t}\n\n\t\t\tif (mode === 'count') {\n\n\t\t\t\tif (!values) {\n\t\t\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'values' required for mode 'count'.\");\n\t\t\t\t}\n\n\t\t\t\t// Divide 0 - 100 in 'count' parts.\n\t\t\t\tvar spread = 100 / (values - 1);\n\t\t\t\tvar v;\n\t\t\t\tvar i = 0;\n\n\t\t\t\tvalues = [];\n\n\t\t\t\t// List these parts and have them handled as 'positions'.\n\t\t\t\twhile ((v = i++ * spread) <= 100) {\n\t\t\t\t\tvalues.push(v);\n\t\t\t\t}\n\n\t\t\t\tmode = 'positions';\n\t\t\t}\n\n\t\t\tif (mode === 'positions') {\n\n\t\t\t\t// Map all percentages to on-range values.\n\t\t\t\treturn values.map(function (value) {\n\t\t\t\t\treturn scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value) : value);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (mode === 'values') {\n\n\t\t\t\t// If the value must be stepped, it needs to be converted to a percentage first.\n\t\t\t\tif (stepped) {\n\n\t\t\t\t\treturn values.map(function (value) {\n\n\t\t\t\t\t\t// Convert to percentage, apply step, return to value.\n\t\t\t\t\t\treturn scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value)));\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, we can simply use the values.\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\n\t\tfunction generateSpread(density, mode, group) {\n\n\t\t\tfunction safeIncrement(value, increment) {\n\t\t\t\t// Avoid floating point variance by dropping the smallest decimal places.\n\t\t\t\treturn (value + increment).toFixed(7) / 1;\n\t\t\t}\n\n\t\t\tvar indexes = {};\n\t\t\tvar firstInRange = scope_Spectrum.xVal[0];\n\t\t\tvar lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1];\n\t\t\tvar ignoreFirst = false;\n\t\t\tvar ignoreLast = false;\n\t\t\tvar prevPct = 0;\n\n\t\t\t// Create a copy of the group, sort it and filter away all duplicates.\n\t\t\tgroup = unique(group.slice().sort(function (a, b) {\n\t\t\t\treturn a - b;\n\t\t\t}));\n\n\t\t\t// Make sure the range starts with the first element.\n\t\t\tif (group[0] !== firstInRange) {\n\t\t\t\tgroup.unshift(firstInRange);\n\t\t\t\tignoreFirst = true;\n\t\t\t}\n\n\t\t\t// Likewise for the last one.\n\t\t\tif (group[group.length - 1] !== lastInRange) {\n\t\t\t\tgroup.push(lastInRange);\n\t\t\t\tignoreLast = true;\n\t\t\t}\n\n\t\t\tgroup.forEach(function (current, index) {\n\n\t\t\t\t// Get the current step and the lower + upper positions.\n\t\t\t\tvar step;\n\t\t\t\tvar i;\n\t\t\t\tvar q;\n\t\t\t\tvar low = current;\n\t\t\t\tvar high = group[index + 1];\n\t\t\t\tvar newPct;\n\t\t\t\tvar pctDifference;\n\t\t\t\tvar pctPos;\n\t\t\t\tvar type;\n\t\t\t\tvar steps;\n\t\t\t\tvar realSteps;\n\t\t\t\tvar stepsize;\n\n\t\t\t\t// When using 'steps' mode, use the provided steps.\n\t\t\t\t// Otherwise, we'll step on to the next subrange.\n\t\t\t\tif (mode === 'steps') {\n\t\t\t\t\tstep = scope_Spectrum.xNumSteps[index];\n\t\t\t\t}\n\n\t\t\t\t// Default to a 'full' step.\n\t\t\t\tif (!step) {\n\t\t\t\t\tstep = high - low;\n\t\t\t\t}\n\n\t\t\t\t// Low can be 0, so test for false. If high is undefined,\n\t\t\t\t// we are at the last subrange. Index 0 is already handled.\n\t\t\t\tif (low === false || high === undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Make sure step isn't 0, which would cause an infinite loop (#654)\n\t\t\t\tstep = Math.max(step, 0.0000001);\n\n\t\t\t\t// Find all steps in the subrange.\n\t\t\t\tfor (i = low; i <= high; i = safeIncrement(i, step)) {\n\n\t\t\t\t\t// Get the percentage value for the current step,\n\t\t\t\t\t// calculate the size for the subrange.\n\t\t\t\t\tnewPct = scope_Spectrum.toStepping(i);\n\t\t\t\t\tpctDifference = newPct - prevPct;\n\n\t\t\t\t\tsteps = pctDifference / density;\n\t\t\t\t\trealSteps = Math.round(steps);\n\n\t\t\t\t\t// This ratio represents the ammount of percentage-space a point indicates.\n\t\t\t\t\t// For a density 1 the points/percentage = 1. For density 2, that percentage needs to be re-devided.\n\t\t\t\t\t// Round the percentage offset to an even number, then divide by two\n\t\t\t\t\t// to spread the offset on both sides of the range.\n\t\t\t\t\tstepsize = pctDifference / realSteps;\n\n\t\t\t\t\t// Divide all points evenly, adding the correct number to this subrange.\n\t\t\t\t\t// Run up to <= so that 100% gets a point, event if ignoreLast is set.\n\t\t\t\t\tfor (q = 1; q <= realSteps; q += 1) {\n\n\t\t\t\t\t\t// The ratio between the rounded value and the actual size might be ~1% off.\n\t\t\t\t\t\t// Correct the percentage offset by the number of points\n\t\t\t\t\t\t// per subrange. density = 1 will result in 100 points on the\n\t\t\t\t\t\t// full range, 2 for 50, 4 for 25, etc.\n\t\t\t\t\t\tpctPos = prevPct + q * stepsize;\n\t\t\t\t\t\tindexes[pctPos.toFixed(5)] = ['x', 0];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Determine the point type.\n\t\t\t\t\ttype = group.indexOf(i) > -1 ? 1 : mode === 'steps' ? 2 : 0;\n\n\t\t\t\t\t// Enforce the 'ignoreFirst' option by overwriting the type for 0.\n\t\t\t\t\tif (!index && ignoreFirst) {\n\t\t\t\t\t\ttype = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!(i === high && ignoreLast)) {\n\t\t\t\t\t\t// Mark the 'type' of this point. 0 = plain, 1 = real value, 2 = step value.\n\t\t\t\t\t\tindexes[newPct.toFixed(5)] = [i, type];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Update the percentage count.\n\t\t\t\t\tprevPct = newPct;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn indexes;\n\t\t}\n\n\t\tfunction addMarking(spread, filterFunc, formatter) {\n\n\t\t\tvar element = document.createElement('div');\n\t\t\tvar out = '';\n\t\t\tvar valueSizeClasses = [options.cssClasses.valueNormal, options.cssClasses.valueLarge, options.cssClasses.valueSub];\n\t\t\tvar markerSizeClasses = [options.cssClasses.markerNormal, options.cssClasses.markerLarge, options.cssClasses.markerSub];\n\t\t\tvar valueOrientationClasses = [options.cssClasses.valueHorizontal, options.cssClasses.valueVertical];\n\t\t\tvar markerOrientationClasses = [options.cssClasses.markerHorizontal, options.cssClasses.markerVertical];\n\n\t\t\taddClass(element, options.cssClasses.pips);\n\t\t\taddClass(element, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);\n\n\t\t\tfunction getClasses(type, source) {\n\t\t\t\tvar a = source === options.cssClasses.value;\n\t\t\t\tvar orientationClasses = a ? valueOrientationClasses : markerOrientationClasses;\n\t\t\t\tvar sizeClasses = a ? valueSizeClasses : markerSizeClasses;\n\n\t\t\t\treturn source + ' ' + orientationClasses[options.ort] + ' ' + sizeClasses[type];\n\t\t\t}\n\n\t\t\tfunction getTags(offset, source, values) {\n\t\t\t\treturn 'class=\"' + getClasses(values[1], source) + '\" style=\"' + options.style + ': ' + offset + '%\"';\n\t\t\t}\n\n\t\t\tfunction addSpread(offset, values) {\n\n\t\t\t\t// Apply the filter function, if it is set.\n\t\t\t\tvalues[1] = values[1] && filterFunc ? filterFunc(values[0], values[1]) : values[1];\n\n\t\t\t\t// Add a marker for every point\n\t\t\t\tout += '<div ' + getTags(offset, options.cssClasses.marker, values) + '></div>';\n\n\t\t\t\t// Values are only appended for points marked '1' or '2'.\n\t\t\t\tif (values[1]) {\n\t\t\t\t\tout += '<div ' + getTags(offset, options.cssClasses.value, values) + '>' + formatter.to(values[0]) + '</div>';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Append all points.\n\t\t\tObject.keys(spread).forEach(function (a) {\n\t\t\t\taddSpread(a, spread[a]);\n\t\t\t});\n\n\t\t\telement.innerHTML = out;\n\n\t\t\treturn element;\n\t\t}\n\n\t\tfunction pips(grid) {\n\n\t\t\tvar mode = grid.mode;\n\t\t\tvar density = grid.density || 1;\n\t\t\tvar filter = grid.filter || false;\n\t\t\tvar values = grid.values || false;\n\t\t\tvar stepped = grid.stepped || false;\n\t\t\tvar group = getGroup(mode, values, stepped);\n\t\t\tvar spread = generateSpread(density, mode, group);\n\t\t\tvar format = grid.format || {\n\t\t\t\tto: Math.round\n\t\t\t};\n\n\t\t\treturn scope_Target.appendChild(addMarking(spread, filter, format));\n\t\t}\n\n\t\t// Shorthand for base dimensions.\n\t\tfunction baseSize() {\n\t\t\tvar rect = scope_Base.getBoundingClientRect(),\n\t\t\t    alt = 'offset' + ['Width', 'Height'][options.ort];\n\t\t\treturn options.ort === 0 ? rect.width || scope_Base[alt] : rect.height || scope_Base[alt];\n\t\t}\n\n\t\t// Handler for attaching events trough a proxy.\n\t\tfunction attachEvent(events, element, callback, data) {\n\n\t\t\t// This function can be used to 'filter' events to the slider.\n\t\t\t// element is a node, not a nodeList\n\n\t\t\tvar method = function method(e) {\n\n\t\t\t\tif (scope_Target.hasAttribute('disabled')) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Stop if an active 'tap' transition is taking place.\n\t\t\t\tif (hasClass(scope_Target, options.cssClasses.tap)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\te = fixEvent(e, data.pageOffset);\n\n\t\t\t\t// Handle reject of multitouch\n\t\t\t\tif (!e) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Ignore right or middle clicks on start #454\n\t\t\t\tif (events === actions.start && e.buttons !== undefined && e.buttons > 1) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Ignore right or middle clicks on start #454\n\t\t\t\tif (data.hover && e.buttons) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\te.calcPoint = e.points[options.ort];\n\n\t\t\t\t// Call the event handler with the event [ and additional data ].\n\t\t\t\tcallback(e, data);\n\t\t\t};\n\n\t\t\tvar methods = [];\n\n\t\t\t// Bind a closure on the target for every event type.\n\t\t\tevents.split(' ').forEach(function (eventName) {\n\t\t\t\telement.addEventListener(eventName, method, false);\n\t\t\t\tmethods.push([eventName, method]);\n\t\t\t});\n\n\t\t\treturn methods;\n\t\t}\n\n\t\t// Provide a clean event with standardized offset values.\n\t\tfunction fixEvent(e, pageOffset) {\n\n\t\t\t// Prevent scrolling and panning on touch events, while\n\t\t\t// attempting to slide. The tap event also depends on this.\n\t\t\te.preventDefault();\n\n\t\t\t// Filter the event to register the type, which can be\n\t\t\t// touch, mouse or pointer. Offset changes need to be\n\t\t\t// made on an event specific basis.\n\t\t\tvar touch = e.type.indexOf('touch') === 0;\n\t\t\tvar mouse = e.type.indexOf('mouse') === 0;\n\t\t\tvar pointer = e.type.indexOf('pointer') === 0;\n\t\t\tvar x;\n\t\t\tvar y;\n\n\t\t\t// IE10 implemented pointer events with a prefix;\n\t\t\tif (e.type.indexOf('MSPointer') === 0) {\n\t\t\t\tpointer = true;\n\t\t\t}\n\n\t\t\tif (touch) {\n\n\t\t\t\t// Fix bug when user touches with two or more fingers on mobile devices.\n\t\t\t\t// It's useful when you have two or more sliders on one page,\n\t\t\t\t// that can be touched simultaneously.\n\t\t\t\t// #649, #663, #668\n\t\t\t\tif (e.touches.length > 1) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// noUiSlider supports one movement at a time,\n\t\t\t\t// so we can select the first 'changedTouch'.\n\t\t\t\tx = e.changedTouches[0].pageX;\n\t\t\t\ty = e.changedTouches[0].pageY;\n\t\t\t}\n\n\t\t\tpageOffset = pageOffset || getPageOffset();\n\n\t\t\tif (mouse || pointer) {\n\t\t\t\tx = e.clientX + pageOffset.x;\n\t\t\t\ty = e.clientY + pageOffset.y;\n\t\t\t}\n\n\t\t\te.pageOffset = pageOffset;\n\t\t\te.points = [x, y];\n\t\t\te.cursor = mouse || pointer; // Fix #435\n\n\t\t\treturn e;\n\t\t}\n\n\t\t// Translate a coordinate in the document to a percentage on the slider\n\t\tfunction calcPointToPercentage(calcPoint) {\n\t\t\tvar location = calcPoint - offset(scope_Base, options.ort);\n\t\t\tvar proposal = location * 100 / baseSize();\n\t\t\treturn options.dir ? 100 - proposal : proposal;\n\t\t}\n\n\t\t// Find handle closest to a certain percentage on the slider\n\t\tfunction getClosestHandle(proposal) {\n\n\t\t\tvar closest = 100;\n\t\t\tvar handleNumber = false;\n\n\t\t\tscope_Handles.forEach(function (handle, index) {\n\n\t\t\t\t// Disabled handles are ignored\n\t\t\t\tif (handle.hasAttribute('disabled')) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar pos = Math.abs(scope_Locations[index] - proposal);\n\n\t\t\t\tif (pos < closest) {\n\t\t\t\t\thandleNumber = index;\n\t\t\t\t\tclosest = pos;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn handleNumber;\n\t\t}\n\n\t\t// Moves handle(s) by a percentage\n\t\t// (bool, % to move, [% where handle started, ...], [index in scope_Handles, ...])\n\t\tfunction moveHandles(upward, proposal, locations, handleNumbers) {\n\n\t\t\tvar proposals = locations.slice();\n\n\t\t\tvar b = [!upward, upward];\n\t\t\tvar f = [upward, !upward];\n\n\t\t\t// Copy handleNumbers so we don't change the dataset\n\t\t\thandleNumbers = handleNumbers.slice();\n\n\t\t\t// Check to see which handle is 'leading'.\n\t\t\t// If that one can't move the second can't either.\n\t\t\tif (upward) {\n\t\t\t\thandleNumbers.reverse();\n\t\t\t}\n\n\t\t\t// Step 1: get the maximum percentage that any of the handles can move\n\t\t\tif (handleNumbers.length > 1) {\n\n\t\t\t\thandleNumbers.forEach(function (handleNumber, o) {\n\n\t\t\t\t\tvar to = checkHandlePosition(proposals, handleNumber, proposals[handleNumber] + proposal, b[o], f[o]);\n\n\t\t\t\t\t// Stop if one of the handles can't move.\n\t\t\t\t\tif (to === false) {\n\t\t\t\t\t\tproposal = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tproposal = to - proposals[handleNumber];\n\t\t\t\t\t\tproposals[handleNumber] = to;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// If using one handle, check backward AND forward\n\t\t\telse {\n\t\t\t\t\tb = f = [true];\n\t\t\t\t}\n\n\t\t\tvar state = false;\n\n\t\t\t// Step 2: Try to set the handles with the found percentage\n\t\t\thandleNumbers.forEach(function (handleNumber, o) {\n\t\t\t\tstate = setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o]) || state;\n\t\t\t});\n\n\t\t\t// Step 3: If a handle moved, fire events\n\t\t\tif (state) {\n\t\t\t\thandleNumbers.forEach(function (handleNumber) {\n\t\t\t\t\tfireEvent('update', handleNumber);\n\t\t\t\t\tfireEvent('slide', handleNumber);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// External event handling\n\t\tfunction fireEvent(eventName, handleNumber, tap) {\n\n\t\t\tObject.keys(scope_Events).forEach(function (targetEvent) {\n\n\t\t\t\tvar eventType = targetEvent.split('.')[0];\n\n\t\t\t\tif (eventName === eventType) {\n\t\t\t\t\tscope_Events[targetEvent].forEach(function (callback) {\n\n\t\t\t\t\t\tcallback.call(\n\t\t\t\t\t\t// Use the slider public API as the scope ('this')\n\t\t\t\t\t\tscope_Self,\n\t\t\t\t\t\t// Return values as array, so arg_1[arg_2] is always valid.\n\t\t\t\t\t\tscope_Values.map(options.format.to),\n\t\t\t\t\t\t// Handle index, 0 or 1\n\t\t\t\t\t\thandleNumber,\n\t\t\t\t\t\t// Unformatted slider values\n\t\t\t\t\t\tscope_Values.slice(),\n\t\t\t\t\t\t// Event is fired by tap, true or false\n\t\t\t\t\t\ttap || false,\n\t\t\t\t\t\t// Left offset of the handle, in relation to the slider\n\t\t\t\t\t\tscope_Locations.slice());\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Fire 'end' when a mouse or pen leaves the document.\n\t\tfunction documentLeave(event, data) {\n\t\t\tif (event.type === \"mouseout\" && event.target.nodeName === \"HTML\" && event.relatedTarget === null) {\n\t\t\t\teventEnd(event, data);\n\t\t\t}\n\t\t}\n\n\t\t// Handle movement on document for handle and range drag.\n\t\tfunction eventMove(event, data) {\n\n\t\t\t// Fix #498\n\t\t\t// Check value of .buttons in 'start' to work around a bug in IE10 mobile (data.buttonsProperty).\n\t\t\t// https://connect.microsoft.com/IE/feedback/details/927005/mobile-ie10-windows-phone-buttons-property-of-pointermove-event-always-zero\n\t\t\t// IE9 has .buttons and .which zero on mousemove.\n\t\t\t// Firefox breaks the spec MDN defines.\n\t\t\tif (navigator.appVersion.indexOf(\"MSIE 9\") === -1 && event.buttons === 0 && data.buttonsProperty !== 0) {\n\t\t\t\treturn eventEnd(event, data);\n\t\t\t}\n\n\t\t\t// Check if we are moving up or down\n\t\t\tvar movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint);\n\n\t\t\t// Convert the movement into a percentage of the slider width/height\n\t\t\tvar proposal = movement * 100 / data.baseSize;\n\n\t\t\tmoveHandles(movement > 0, proposal, data.locations, data.handleNumbers);\n\t\t}\n\n\t\t// Unbind move events on document, call callbacks.\n\t\tfunction eventEnd(event, data) {\n\n\t\t\t// The handle is no longer active, so remove the class.\n\t\t\tif (scope_ActiveHandle) {\n\t\t\t\tremoveClass(scope_ActiveHandle, options.cssClasses.active);\n\t\t\t\tscope_ActiveHandle = false;\n\t\t\t}\n\n\t\t\t// Remove cursor styles and text-selection events bound to the body.\n\t\t\tif (event.cursor) {\n\t\t\t\tdocument.body.style.cursor = '';\n\t\t\t\tdocument.body.removeEventListener('selectstart', document.body.noUiListener);\n\t\t\t}\n\n\t\t\t// Unbind the move and end events, which are added on 'start'.\n\t\t\tdocument.documentElement.noUiListeners.forEach(function (c) {\n\t\t\t\tdocument.documentElement.removeEventListener(c[0], c[1]);\n\t\t\t});\n\n\t\t\t// Remove dragging class.\n\t\t\tremoveClass(scope_Target, options.cssClasses.drag);\n\n\t\t\tsetZindex();\n\n\t\t\tdata.handleNumbers.forEach(function (handleNumber) {\n\t\t\t\tfireEvent('set', handleNumber);\n\t\t\t\tfireEvent('change', handleNumber);\n\t\t\t\tfireEvent('end', handleNumber);\n\t\t\t});\n\t\t}\n\n\t\t// Bind move events on document.\n\t\tfunction eventStart(event, data) {\n\n\t\t\tif (data.handleNumbers.length === 1) {\n\n\t\t\t\tvar handle = scope_Handles[data.handleNumbers[0]];\n\n\t\t\t\t// Ignore 'disabled' handles\n\t\t\t\tif (handle.hasAttribute('disabled')) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Mark the handle as 'active' so it can be styled.\n\t\t\t\tscope_ActiveHandle = handle.children[0];\n\t\t\t\taddClass(scope_ActiveHandle, options.cssClasses.active);\n\t\t\t}\n\n\t\t\t// Fix #551, where a handle gets selected instead of dragged.\n\t\t\tevent.preventDefault();\n\n\t\t\t// A drag should never propagate up to the 'tap' event.\n\t\t\tevent.stopPropagation();\n\n\t\t\t// Attach the move and end events.\n\t\t\tvar moveEvent = attachEvent(actions.move, document.documentElement, eventMove, {\n\t\t\t\tstartCalcPoint: event.calcPoint,\n\t\t\t\tbaseSize: baseSize(),\n\t\t\t\tpageOffset: event.pageOffset,\n\t\t\t\thandleNumbers: data.handleNumbers,\n\t\t\t\tbuttonsProperty: event.buttons,\n\t\t\t\tlocations: scope_Locations.slice()\n\t\t\t});\n\n\t\t\tvar endEvent = attachEvent(actions.end, document.documentElement, eventEnd, {\n\t\t\t\thandleNumbers: data.handleNumbers\n\t\t\t});\n\n\t\t\tvar outEvent = attachEvent(\"mouseout\", document.documentElement, documentLeave, {\n\t\t\t\thandleNumbers: data.handleNumbers\n\t\t\t});\n\n\t\t\tdocument.documentElement.noUiListeners = moveEvent.concat(endEvent, outEvent);\n\n\t\t\t// Text selection isn't an issue on touch devices,\n\t\t\t// so adding cursor styles can be skipped.\n\t\t\tif (event.cursor) {\n\n\t\t\t\t// Prevent the 'I' cursor and extend the range-drag cursor.\n\t\t\t\tdocument.body.style.cursor = getComputedStyle(event.target).cursor;\n\n\t\t\t\t// Mark the target with a dragging state.\n\t\t\t\tif (scope_Handles.length > 1) {\n\t\t\t\t\taddClass(scope_Target, options.cssClasses.drag);\n\t\t\t\t}\n\n\t\t\t\tvar f = function f() {\n\t\t\t\t\treturn false;\n\t\t\t\t};\n\n\t\t\t\tdocument.body.noUiListener = f;\n\n\t\t\t\t// Prevent text selection when dragging the handles.\n\t\t\t\tdocument.body.addEventListener('selectstart', f, false);\n\t\t\t}\n\n\t\t\tdata.handleNumbers.forEach(function (handleNumber) {\n\t\t\t\tfireEvent('start', handleNumber);\n\t\t\t});\n\t\t}\n\n\t\t// Move closest handle to tapped location.\n\t\tfunction eventTap(event) {\n\n\t\t\t// The tap event shouldn't propagate up\n\t\t\tevent.stopPropagation();\n\n\t\t\tvar proposal = calcPointToPercentage(event.calcPoint);\n\t\t\tvar handleNumber = getClosestHandle(proposal);\n\n\t\t\t// Tackle the case that all handles are 'disabled'.\n\t\t\tif (handleNumber === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Flag the slider as it is now in a transitional state.\n\t\t\t// Transition takes a configurable amount of ms (default 300). Re-enable the slider after that.\n\t\t\tif (!options.events.snap) {\n\t\t\t\taddClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);\n\t\t\t}\n\n\t\t\tsetHandle(handleNumber, proposal, true, true);\n\n\t\t\tsetZindex();\n\n\t\t\tfireEvent('slide', handleNumber, true);\n\t\t\tfireEvent('set', handleNumber, true);\n\t\t\tfireEvent('change', handleNumber, true);\n\t\t\tfireEvent('update', handleNumber, true);\n\n\t\t\tif (options.events.snap) {\n\t\t\t\teventStart(event, { handleNumbers: [handleNumber] });\n\t\t\t}\n\t\t}\n\n\t\t// Fires a 'hover' event for a hovered mouse/pen position.\n\t\tfunction eventHover(event) {\n\n\t\t\tvar proposal = calcPointToPercentage(event.calcPoint);\n\n\t\t\tvar to = scope_Spectrum.getStep(proposal);\n\t\t\tvar value = scope_Spectrum.fromStepping(to);\n\n\t\t\tObject.keys(scope_Events).forEach(function (targetEvent) {\n\t\t\t\tif ('hover' === targetEvent.split('.')[0]) {\n\t\t\t\t\tscope_Events[targetEvent].forEach(function (callback) {\n\t\t\t\t\t\tcallback.call(scope_Self, value);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Attach events to several slider parts.\n\t\tfunction bindSliderEvents(behaviour) {\n\n\t\t\t// Attach the standard drag event to the handles.\n\t\t\tif (!behaviour.fixed) {\n\n\t\t\t\tscope_Handles.forEach(function (handle, index) {\n\n\t\t\t\t\t// These events are only bound to the visual handle\n\t\t\t\t\t// element, not the 'real' origin element.\n\t\t\t\t\tattachEvent(actions.start, handle.children[0], eventStart, {\n\t\t\t\t\t\thandleNumbers: [index]\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Attach the tap event to the slider base.\n\t\t\tif (behaviour.tap) {\n\t\t\t\tattachEvent(actions.start, scope_Base, eventTap, {});\n\t\t\t}\n\n\t\t\t// Fire hover events\n\t\t\tif (behaviour.hover) {\n\t\t\t\tattachEvent(actions.move, scope_Base, eventHover, { hover: true });\n\t\t\t}\n\n\t\t\t// Make the range draggable.\n\t\t\tif (behaviour.drag) {\n\n\t\t\t\tscope_Connects.forEach(function (connect, index) {\n\n\t\t\t\t\tif (connect === false || index === 0 || index === scope_Connects.length - 1) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar handleBefore = scope_Handles[index - 1];\n\t\t\t\t\tvar handleAfter = scope_Handles[index];\n\t\t\t\t\tvar eventHolders = [connect];\n\n\t\t\t\t\taddClass(connect, options.cssClasses.draggable);\n\n\t\t\t\t\t// When the range is fixed, the entire range can\n\t\t\t\t\t// be dragged by the handles. The handle in the first\n\t\t\t\t\t// origin will propagate the start event upward,\n\t\t\t\t\t// but it needs to be bound manually on the other.\n\t\t\t\t\tif (behaviour.fixed) {\n\t\t\t\t\t\teventHolders.push(handleBefore.children[0]);\n\t\t\t\t\t\teventHolders.push(handleAfter.children[0]);\n\t\t\t\t\t}\n\n\t\t\t\t\teventHolders.forEach(function (eventHolder) {\n\t\t\t\t\t\tattachEvent(actions.start, eventHolder, eventStart, {\n\t\t\t\t\t\t\thandles: [handleBefore, handleAfter],\n\t\t\t\t\t\t\thandleNumbers: [index - 1, index]\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Split out the handle positioning logic so the Move event can use it, too\n\t\tfunction checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward) {\n\n\t\t\t// For sliders with multiple handles, limit movement to the other handle.\n\t\t\t// Apply the margin option by adding it to the handle positions.\n\t\t\tif (scope_Handles.length > 1) {\n\n\t\t\t\tif (lookBackward && handleNumber > 0) {\n\t\t\t\t\tto = Math.max(to, reference[handleNumber - 1] + options.margin);\n\t\t\t\t}\n\n\t\t\t\tif (lookForward && handleNumber < scope_Handles.length - 1) {\n\t\t\t\t\tto = Math.min(to, reference[handleNumber + 1] - options.margin);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// The limit option has the opposite effect, limiting handles to a\n\t\t\t// maximum distance from another. Limit must be > 0, as otherwise\n\t\t\t// handles would be unmoveable.\n\t\t\tif (scope_Handles.length > 1 && options.limit) {\n\n\t\t\t\tif (lookBackward && handleNumber > 0) {\n\t\t\t\t\tto = Math.min(to, reference[handleNumber - 1] + options.limit);\n\t\t\t\t}\n\n\t\t\t\tif (lookForward && handleNumber < scope_Handles.length - 1) {\n\t\t\t\t\tto = Math.max(to, reference[handleNumber + 1] - options.limit);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// The padding option keeps the handles a certain distance from the\n\t\t\t// edges of the slider. Padding must be > 0.\n\t\t\tif (options.padding) {\n\n\t\t\t\tif (handleNumber === 0) {\n\t\t\t\t\tto = Math.max(to, options.padding);\n\t\t\t\t}\n\n\t\t\t\tif (handleNumber === scope_Handles.length - 1) {\n\t\t\t\t\tto = Math.min(to, 100 - options.padding);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tto = scope_Spectrum.getStep(to);\n\n\t\t\t// Limit percentage to the 0 - 100 range\n\t\t\tto = limit(to);\n\n\t\t\t// Return false if handle can't move\n\t\t\tif (to === reference[handleNumber]) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn to;\n\t\t}\n\n\t\tfunction toPct(pct) {\n\t\t\treturn pct + '%';\n\t\t}\n\n\t\t// Updates scope_Locations and scope_Values, updates visual state\n\t\tfunction updateHandlePosition(handleNumber, to) {\n\n\t\t\t// Update locations.\n\t\t\tscope_Locations[handleNumber] = to;\n\n\t\t\t// Convert the value to the slider stepping/range.\n\t\t\tscope_Values[handleNumber] = scope_Spectrum.fromStepping(to);\n\n\t\t\t// Called synchronously or on the next animationFrame\n\t\t\tvar stateUpdate = function stateUpdate() {\n\t\t\t\tscope_Handles[handleNumber].style[options.style] = toPct(to);\n\t\t\t\tupdateConnect(handleNumber);\n\t\t\t\tupdateConnect(handleNumber + 1);\n\t\t\t};\n\n\t\t\t// Set the handle to the new position.\n\t\t\t// Use requestAnimationFrame for efficient painting.\n\t\t\t// No significant effect in Chrome, Edge sees dramatic performace improvements.\n\t\t\t// Option to disable is useful for unit tests, and single-step debugging.\n\t\t\tif (window.requestAnimationFrame && options.useRequestAnimationFrame) {\n\t\t\t\twindow.requestAnimationFrame(stateUpdate);\n\t\t\t} else {\n\t\t\t\tstateUpdate();\n\t\t\t}\n\t\t}\n\n\t\tfunction setZindex() {\n\n\t\t\tscope_HandleNumbers.forEach(function (handleNumber) {\n\t\t\t\t// Handles before the slider middle are stacked later = higher,\n\t\t\t\t// Handles after the middle later is lower\n\t\t\t\t// [[7] [8] .......... | .......... [5] [4]\n\t\t\t\tvar dir = scope_Locations[handleNumber] > 50 ? -1 : 1;\n\t\t\t\tvar zIndex = 3 + (scope_Handles.length + dir * handleNumber);\n\t\t\t\tscope_Handles[handleNumber].childNodes[0].style.zIndex = zIndex;\n\t\t\t});\n\t\t}\n\n\t\t// Test suggested values and apply margin, step.\n\t\tfunction setHandle(handleNumber, to, lookBackward, lookForward) {\n\n\t\t\tto = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward);\n\n\t\t\tif (to === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tupdateHandlePosition(handleNumber, to);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// Updates style attribute for connect nodes\n\t\tfunction updateConnect(index) {\n\n\t\t\t// Skip connects set to false\n\t\t\tif (!scope_Connects[index]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar l = 0;\n\t\t\tvar h = 100;\n\n\t\t\tif (index !== 0) {\n\t\t\t\tl = scope_Locations[index - 1];\n\t\t\t}\n\n\t\t\tif (index !== scope_Connects.length - 1) {\n\t\t\t\th = scope_Locations[index];\n\t\t\t}\n\n\t\t\tscope_Connects[index].style[options.style] = toPct(l);\n\t\t\tscope_Connects[index].style[options.styleOposite] = toPct(100 - h);\n\t\t}\n\n\t\t// ...\n\t\tfunction setValue(to, handleNumber) {\n\n\t\t\t// Setting with null indicates an 'ignore'.\n\t\t\t// Inputting 'false' is invalid.\n\t\t\tif (to === null || to === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a formatted number was passed, attemt to decode it.\n\t\t\tif (typeof to === 'number') {\n\t\t\t\tto = String(to);\n\t\t\t}\n\n\t\t\tto = options.format.from(to);\n\n\t\t\t// Request an update for all links if the value was invalid.\n\t\t\t// Do so too if setting the handle fails.\n\t\t\tif (to !== false && !isNaN(to)) {\n\t\t\t\tsetHandle(handleNumber, scope_Spectrum.toStepping(to), false, false);\n\t\t\t}\n\t\t}\n\n\t\t// Set the slider value.\n\t\tfunction valueSet(input, fireSetEvent) {\n\n\t\t\tvar values = asArray(input);\n\t\t\tvar isInit = scope_Locations[0] === undefined;\n\n\t\t\t// Event fires by default\n\t\t\tfireSetEvent = fireSetEvent === undefined ? true : !!fireSetEvent;\n\n\t\t\tvalues.forEach(setValue);\n\n\t\t\t// Animation is optional.\n\t\t\t// Make sure the initial values were set before using animated placement.\n\t\t\tif (options.animate && !isInit) {\n\t\t\t\taddClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);\n\t\t\t}\n\n\t\t\t// Now that all base values are set, apply constraints\n\t\t\tscope_HandleNumbers.forEach(function (handleNumber) {\n\t\t\t\tsetHandle(handleNumber, scope_Locations[handleNumber], true, false);\n\t\t\t});\n\n\t\t\tsetZindex();\n\n\t\t\tscope_HandleNumbers.forEach(function (handleNumber) {\n\n\t\t\t\tfireEvent('update', handleNumber);\n\n\t\t\t\t// Fire the event only for handles that received a new value, as per #579\n\t\t\t\tif (values[handleNumber] !== null && fireSetEvent) {\n\t\t\t\t\tfireEvent('set', handleNumber);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Reset slider to initial values\n\t\tfunction valueReset(fireSetEvent) {\n\t\t\tvalueSet(options.start, fireSetEvent);\n\t\t}\n\n\t\t// Get the slider value.\n\t\tfunction valueGet() {\n\n\t\t\tvar values = scope_Values.map(options.format.to);\n\n\t\t\t// If only one handle is used, return a single value.\n\t\t\tif (values.length === 1) {\n\t\t\t\treturn values[0];\n\t\t\t}\n\n\t\t\treturn values;\n\t\t}\n\n\t\t// Removes classes from the root and empties it.\n\t\tfunction destroy() {\n\n\t\t\tfor (var key in options.cssClasses) {\n\t\t\t\tif (!options.cssClasses.hasOwnProperty(key)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tremoveClass(scope_Target, options.cssClasses[key]);\n\t\t\t}\n\n\t\t\twhile (scope_Target.firstChild) {\n\t\t\t\tscope_Target.removeChild(scope_Target.firstChild);\n\t\t\t}\n\n\t\t\tdelete scope_Target.noUiSlider;\n\t\t}\n\n\t\t// Get the current step size for the slider.\n\t\tfunction getCurrentStep() {\n\n\t\t\t// Check all locations, map them to their stepping point.\n\t\t\t// Get the step point, then find it in the input list.\n\t\t\treturn scope_Locations.map(function (location, index) {\n\n\t\t\t\tvar nearbySteps = scope_Spectrum.getNearbySteps(location);\n\t\t\t\tvar value = scope_Values[index];\n\t\t\t\tvar increment = nearbySteps.thisStep.step;\n\t\t\t\tvar decrement = null;\n\n\t\t\t\t// If the next value in this step moves into the next step,\n\t\t\t\t// the increment is the start of the next step - the current value\n\t\t\t\tif (increment !== false) {\n\t\t\t\t\tif (value + increment > nearbySteps.stepAfter.startValue) {\n\t\t\t\t\t\tincrement = nearbySteps.stepAfter.startValue - value;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If the value is beyond the starting point\n\t\t\t\tif (value > nearbySteps.thisStep.startValue) {\n\t\t\t\t\tdecrement = nearbySteps.thisStep.step;\n\t\t\t\t} else if (nearbySteps.stepBefore.step === false) {\n\t\t\t\t\tdecrement = false;\n\t\t\t\t}\n\n\t\t\t\t// If a handle is at the start of a step, it always steps back into the previous step first\n\t\t\t\telse {\n\t\t\t\t\t\tdecrement = value - nearbySteps.stepBefore.highestStep;\n\t\t\t\t\t}\n\n\t\t\t\t// Now, if at the slider edges, there is not in/decrement\n\t\t\t\tif (location === 100) {\n\t\t\t\t\tincrement = null;\n\t\t\t\t} else if (location === 0) {\n\t\t\t\t\tdecrement = null;\n\t\t\t\t}\n\n\t\t\t\t// As per #391, the comparison for the decrement step can have some rounding issues.\n\t\t\t\tvar stepDecimals = scope_Spectrum.countStepDecimals();\n\n\t\t\t\t// Round per #391\n\t\t\t\tif (increment !== null && increment !== false) {\n\t\t\t\t\tincrement = Number(increment.toFixed(stepDecimals));\n\t\t\t\t}\n\n\t\t\t\tif (decrement !== null && decrement !== false) {\n\t\t\t\t\tdecrement = Number(decrement.toFixed(stepDecimals));\n\t\t\t\t}\n\n\t\t\t\treturn [decrement, increment];\n\t\t\t});\n\t\t}\n\n\t\t// Attach an event to this slider, possibly including a namespace\n\t\tfunction bindEvent(namespacedEvent, callback) {\n\t\t\tscope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];\n\t\t\tscope_Events[namespacedEvent].push(callback);\n\n\t\t\t// If the event bound is 'update,' fire it immediately for all handles.\n\t\t\tif (namespacedEvent.split('.')[0] === 'update') {\n\t\t\t\tscope_Handles.forEach(function (a, index) {\n\t\t\t\t\tfireEvent('update', index);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Undo attachment of event\n\t\tfunction removeEvent(namespacedEvent) {\n\n\t\t\tvar event = namespacedEvent && namespacedEvent.split('.')[0];\n\t\t\tvar namespace = event && namespacedEvent.substring(event.length);\n\n\t\t\tObject.keys(scope_Events).forEach(function (bind) {\n\n\t\t\t\tvar tEvent = bind.split('.')[0],\n\t\t\t\t    tNamespace = bind.substring(tEvent.length);\n\n\t\t\t\tif ((!event || event === tEvent) && (!namespace || namespace === tNamespace)) {\n\t\t\t\t\tdelete scope_Events[bind];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Updateable: margin, limit, padding, step, range, animate, snap\n\t\tfunction updateOptions(optionsToUpdate, fireSetEvent) {\n\n\t\t\t// Spectrum is created using the range, snap, direction and step options.\n\t\t\t// 'snap' and 'step' can be updated, 'direction' cannot, due to event binding.\n\t\t\t// If 'snap' and 'step' are not passed, they should remain unchanged.\n\t\t\tvar v = valueGet();\n\n\t\t\tvar updateAble = ['margin', 'limit', 'padding', 'range', 'animate', 'snap', 'step', 'format'];\n\n\t\t\t// Only change options that we're actually passed to update.\n\t\t\tupdateAble.forEach(function (name) {\n\t\t\t\tif (optionsToUpdate[name] !== undefined) {\n\t\t\t\t\toriginalOptions[name] = optionsToUpdate[name];\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tvar newOptions = testOptions(originalOptions);\n\n\t\t\t// Load new options into the slider state\n\t\t\tupdateAble.forEach(function (name) {\n\t\t\t\tif (optionsToUpdate[name] !== undefined) {\n\t\t\t\t\toptions[name] = newOptions[name];\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Save current spectrum direction as testOptions in testRange call\n\t\t\t// doesn't rely on current direction\n\t\t\tnewOptions.spectrum.direction = scope_Spectrum.direction;\n\t\t\tscope_Spectrum = newOptions.spectrum;\n\n\t\t\t// Limit, margin and padding depend on the spectrum but are stored outside of it. (#677)\n\t\t\toptions.margin = newOptions.margin;\n\t\t\toptions.limit = newOptions.limit;\n\t\t\toptions.padding = newOptions.padding;\n\n\t\t\t// Invalidate the current positioning so valueSet forces an update.\n\t\t\tscope_Locations = [];\n\t\t\tvalueSet(optionsToUpdate.start || v, fireSetEvent);\n\t\t}\n\n\t\t// Throw an error if the slider was already initialized.\n\t\tif (scope_Target.noUiSlider) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): Slider was already initialized.\");\n\t\t}\n\n\t\t// Create the base element, initialise HTML and set classes.\n\t\t// Add handles and connect elements.\n\t\taddSlider(scope_Target);\n\t\taddElements(options.connect, scope_Base);\n\n\t\tscope_Self = {\n\t\t\tdestroy: destroy,\n\t\t\tsteps: getCurrentStep,\n\t\t\ton: bindEvent,\n\t\t\toff: removeEvent,\n\t\t\tget: valueGet,\n\t\t\tset: valueSet,\n\t\t\treset: valueReset,\n\t\t\t// Exposed for unit testing, don't use this in your application.\n\t\t\t__moveHandles: function __moveHandles(a, b, c) {\n\t\t\t\tmoveHandles(a, b, scope_Locations, c);\n\t\t\t},\n\t\t\toptions: originalOptions, // Issue #600, #678\n\t\t\tupdateOptions: updateOptions,\n\t\t\ttarget: scope_Target, // Issue #597\n\t\t\tpips: pips // Issue #594\n\t\t};\n\n\t\t// Attach user events.\n\t\tbindSliderEvents(options.events);\n\n\t\t// Use the public value method to set the start values.\n\t\tvalueSet(options.start);\n\n\t\tif (options.pips) {\n\t\t\tpips(options.pips);\n\t\t}\n\n\t\tif (options.tooltips) {\n\t\t\ttooltips();\n\t\t}\n\n\t\treturn scope_Self;\n\t}\n\n\t// Run the standard initializer\n\tfunction initialize(target, originalOptions) {\n\n\t\tif (!target.nodeName) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): create requires a single element.\");\n\t\t}\n\n\t\t// Test the options and create the slider environment;\n\t\tvar options = testOptions(originalOptions, target);\n\t\tvar api = closure(target, options, originalOptions);\n\n\t\ttarget.noUiSlider = api;\n\n\t\treturn api;\n\t}\n\n\t// Use an object instead of a function for future expansibility;\n\treturn {\n\t\tversion: VERSION,\n\t\tcreate: initialize\n\t};\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L25vdWlzbGlkZXIvZGlzdHJpYnV0ZS9ub3Vpc2xpZGVyLmpzPzgxMDkiXSwibmFtZXMiOlsiZmFjdG9yeSIsImRlZmluZSIsImV4cG9ydHMiLCJtb2R1bGUiLCJ3aW5kb3ciLCJub1VpU2xpZGVyIiwiVkVSU0lPTiIsImFkZE5vZGVUbyIsInRhcmdldCIsImNsYXNzTmFtZSIsImRpdiIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImFkZENsYXNzIiwiYXBwZW5kQ2hpbGQiLCJ1bmlxdWUiLCJhcnJheSIsImZpbHRlciIsImEiLCJjbG9zZXN0IiwidmFsdWUiLCJ0byIsIk1hdGgiLCJyb3VuZCIsIm9mZnNldCIsImVsZW0iLCJvcmllbnRhdGlvbiIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJkb2MiLCJvd25lckRvY3VtZW50IiwiZG9jRWxlbSIsImRvY3VtZW50RWxlbWVudCIsInBhZ2VPZmZzZXQiLCJnZXRQYWdlT2Zmc2V0IiwidGVzdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIngiLCJ0b3AiLCJ5IiwiY2xpZW50VG9wIiwibGVmdCIsImNsaWVudExlZnQiLCJpc051bWVyaWMiLCJpc05hTiIsImlzRmluaXRlIiwiYWRkQ2xhc3NGb3IiLCJlbGVtZW50IiwiZHVyYXRpb24iLCJzZXRUaW1lb3V0IiwicmVtb3ZlQ2xhc3MiLCJsaW1pdCIsIm1heCIsIm1pbiIsImFzQXJyYXkiLCJBcnJheSIsImlzQXJyYXkiLCJjb3VudERlY2ltYWxzIiwibnVtU3RyIiwiU3RyaW5nIiwicGllY2VzIiwic3BsaXQiLCJsZW5ndGgiLCJlbCIsImNsYXNzTGlzdCIsImFkZCIsInJlbW92ZSIsInJlcGxhY2UiLCJSZWdFeHAiLCJqb2luIiwiaGFzQ2xhc3MiLCJjb250YWlucyIsInN1cHBvcnRQYWdlT2Zmc2V0IiwicGFnZVhPZmZzZXQiLCJ1bmRlZmluZWQiLCJpc0NTUzFDb21wYXQiLCJjb21wYXRNb2RlIiwic2Nyb2xsTGVmdCIsImJvZHkiLCJwYWdlWU9mZnNldCIsInNjcm9sbFRvcCIsImdldEFjdGlvbnMiLCJwb2ludGVyRW5hYmxlZCIsInN0YXJ0IiwibW92ZSIsImVuZCIsIm1zUG9pbnRlckVuYWJsZWQiLCJzdWJSYW5nZVJhdGlvIiwicGEiLCJwYiIsImZyb21QZXJjZW50YWdlIiwicmFuZ2UiLCJ0b1BlcmNlbnRhZ2UiLCJhYnMiLCJpc1BlcmNlbnRhZ2UiLCJnZXRKIiwiYXJyIiwiaiIsInRvU3RlcHBpbmciLCJ4VmFsIiwieFBjdCIsInNsaWNlIiwidmEiLCJ2YiIsImZyb21TdGVwcGluZyIsImdldFN0ZXAiLCJ4U3RlcHMiLCJzbmFwIiwiYiIsImhhbmRsZUVudHJ5UG9pbnQiLCJpbmRleCIsInRoYXQiLCJwZXJjZW50YWdlIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiRXJyb3IiLCJwYXJzZUZsb2F0IiwicHVzaCIsInhIaWdoZXN0Q29tcGxldGVTdGVwIiwiaGFuZGxlU3RlcFBvaW50IiwiaSIsIm4iLCJ0b3RhbFN0ZXBzIiwieE51bVN0ZXBzIiwiaGlnaGVzdFN0ZXAiLCJjZWlsIiwiTnVtYmVyIiwidG9GaXhlZCIsInN0ZXAiLCJTcGVjdHJ1bSIsImVudHJ5IiwiZGlyZWN0aW9uIiwic2luZ2xlU3RlcCIsIm9yZGVyZWQiLCJoYXNPd25Qcm9wZXJ0eSIsInNvcnQiLCJnZXRNYXJnaW4iLCJnZXROZWFyYnlTdGVwcyIsInN0ZXBCZWZvcmUiLCJzdGFydFZhbHVlIiwidGhpc1N0ZXAiLCJzdGVwQWZ0ZXIiLCJjb3VudFN0ZXBEZWNpbWFscyIsInN0ZXBEZWNpbWFscyIsIm1hcCIsImFwcGx5IiwiY29udmVydCIsImRlZmF1bHRGb3JtYXR0ZXIiLCJ0ZXN0U3RlcCIsInBhcnNlZCIsInRlc3RSYW5nZSIsInNwZWN0cnVtIiwiZGlyIiwidGVzdFN0YXJ0IiwiaGFuZGxlcyIsInRlc3RTbmFwIiwidGVzdEFuaW1hdGUiLCJhbmltYXRlIiwidGVzdEFuaW1hdGlvbkR1cmF0aW9uIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJ0ZXN0Q29ubmVjdCIsImNvbm5lY3QiLCJ0ZXN0T3JpZW50YXRpb24iLCJvcnQiLCJ0ZXN0TWFyZ2luIiwibWFyZ2luIiwidGVzdExpbWl0IiwidGVzdFBhZGRpbmciLCJwYWRkaW5nIiwidGVzdERpcmVjdGlvbiIsInRlc3RCZWhhdmlvdXIiLCJ0YXAiLCJpbmRleE9mIiwiZHJhZyIsImZpeGVkIiwiaG92ZXIiLCJldmVudHMiLCJ0ZXN0VG9vbHRpcHMiLCJ0b29sdGlwcyIsImZvckVhY2giLCJmb3JtYXR0ZXIiLCJ0ZXN0Rm9ybWF0IiwiZm9ybWF0IiwiZnJvbSIsInRlc3RDc3NQcmVmaXgiLCJjc3NQcmVmaXgiLCJ0ZXN0Q3NzQ2xhc3NlcyIsImNzc0NsYXNzZXMiLCJrZXkiLCJ0ZXN0VXNlUmFmIiwidXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwidGVzdE9wdGlvbnMiLCJvcHRpb25zIiwidGVzdHMiLCJyIiwidCIsImRlZmF1bHRzIiwiYmFzZSIsIm9yaWdpbiIsImhhbmRsZSIsImhhbmRsZUxvd2VyIiwiaGFuZGxlVXBwZXIiLCJob3Jpem9udGFsIiwidmVydGljYWwiLCJiYWNrZ3JvdW5kIiwibHRyIiwicnRsIiwiZHJhZ2dhYmxlIiwiYWN0aXZlIiwidG9vbHRpcCIsInBpcHMiLCJwaXBzSG9yaXpvbnRhbCIsInBpcHNWZXJ0aWNhbCIsIm1hcmtlciIsIm1hcmtlckhvcml6b250YWwiLCJtYXJrZXJWZXJ0aWNhbCIsIm1hcmtlck5vcm1hbCIsIm1hcmtlckxhcmdlIiwibWFya2VyU3ViIiwidmFsdWVIb3Jpem9udGFsIiwidmFsdWVWZXJ0aWNhbCIsInZhbHVlTm9ybWFsIiwidmFsdWVMYXJnZSIsInZhbHVlU3ViIiwia2V5cyIsIm5hbWUiLCJzdHlsZXMiLCJzdHlsZSIsInN0eWxlT3Bvc2l0ZSIsImNsb3N1cmUiLCJvcmlnaW5hbE9wdGlvbnMiLCJhY3Rpb25zIiwic2NvcGVfVGFyZ2V0Iiwic2NvcGVfTG9jYXRpb25zIiwic2NvcGVfQmFzZSIsInNjb3BlX0hhbmRsZXMiLCJzY29wZV9IYW5kbGVOdW1iZXJzIiwic2NvcGVfQWN0aXZlSGFuZGxlIiwic2NvcGVfQ29ubmVjdHMiLCJzY29wZV9TcGVjdHJ1bSIsInNjb3BlX1ZhbHVlcyIsInNjb3BlX0V2ZW50cyIsInNjb3BlX1NlbGYiLCJhZGRPcmlnaW4iLCJoYW5kbGVOdW1iZXIiLCJzZXRBdHRyaWJ1dGUiLCJhZGRDb25uZWN0IiwiYWRkRWxlbWVudHMiLCJjb25uZWN0T3B0aW9ucyIsImFkZFNsaWRlciIsImFkZFRvb2x0aXAiLCJmaXJzdENoaWxkIiwidGlwcyIsImJpbmRFdmVudCIsInZhbHVlcyIsInVuZW5jb2RlZCIsImZvcm1hdHRlZFZhbHVlIiwiaW5uZXJIVE1MIiwiZ2V0R3JvdXAiLCJtb2RlIiwic3RlcHBlZCIsInNwcmVhZCIsInYiLCJnZW5lcmF0ZVNwcmVhZCIsImRlbnNpdHkiLCJncm91cCIsInNhZmVJbmNyZW1lbnQiLCJpbmNyZW1lbnQiLCJpbmRleGVzIiwiZmlyc3RJblJhbmdlIiwibGFzdEluUmFuZ2UiLCJpZ25vcmVGaXJzdCIsImlnbm9yZUxhc3QiLCJwcmV2UGN0IiwidW5zaGlmdCIsImN1cnJlbnQiLCJxIiwibG93IiwiaGlnaCIsIm5ld1BjdCIsInBjdERpZmZlcmVuY2UiLCJwY3RQb3MiLCJ0eXBlIiwic3RlcHMiLCJyZWFsU3RlcHMiLCJzdGVwc2l6ZSIsImFkZE1hcmtpbmciLCJmaWx0ZXJGdW5jIiwib3V0IiwidmFsdWVTaXplQ2xhc3NlcyIsIm1hcmtlclNpemVDbGFzc2VzIiwidmFsdWVPcmllbnRhdGlvbkNsYXNzZXMiLCJtYXJrZXJPcmllbnRhdGlvbkNsYXNzZXMiLCJnZXRDbGFzc2VzIiwic291cmNlIiwib3JpZW50YXRpb25DbGFzc2VzIiwic2l6ZUNsYXNzZXMiLCJnZXRUYWdzIiwiYWRkU3ByZWFkIiwiZ3JpZCIsImJhc2VTaXplIiwiYWx0Iiwid2lkdGgiLCJoZWlnaHQiLCJhdHRhY2hFdmVudCIsImNhbGxiYWNrIiwiZGF0YSIsIm1ldGhvZCIsImUiLCJoYXNBdHRyaWJ1dGUiLCJmaXhFdmVudCIsImJ1dHRvbnMiLCJjYWxjUG9pbnQiLCJwb2ludHMiLCJtZXRob2RzIiwiZXZlbnROYW1lIiwiYWRkRXZlbnRMaXN0ZW5lciIsInByZXZlbnREZWZhdWx0IiwidG91Y2giLCJtb3VzZSIsInBvaW50ZXIiLCJ0b3VjaGVzIiwiY2hhbmdlZFRvdWNoZXMiLCJwYWdlWCIsInBhZ2VZIiwiY2xpZW50WCIsImNsaWVudFkiLCJjdXJzb3IiLCJjYWxjUG9pbnRUb1BlcmNlbnRhZ2UiLCJsb2NhdGlvbiIsInByb3Bvc2FsIiwiZ2V0Q2xvc2VzdEhhbmRsZSIsInBvcyIsIm1vdmVIYW5kbGVzIiwidXB3YXJkIiwibG9jYXRpb25zIiwiaGFuZGxlTnVtYmVycyIsInByb3Bvc2FscyIsImYiLCJyZXZlcnNlIiwibyIsImNoZWNrSGFuZGxlUG9zaXRpb24iLCJzdGF0ZSIsInNldEhhbmRsZSIsImZpcmVFdmVudCIsInRhcmdldEV2ZW50IiwiZXZlbnRUeXBlIiwiZG9jdW1lbnRMZWF2ZSIsImV2ZW50Iiwibm9kZU5hbWUiLCJyZWxhdGVkVGFyZ2V0IiwiZXZlbnRFbmQiLCJldmVudE1vdmUiLCJhcHBWZXJzaW9uIiwiYnV0dG9uc1Byb3BlcnR5IiwibW92ZW1lbnQiLCJzdGFydENhbGNQb2ludCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJub1VpTGlzdGVuZXIiLCJub1VpTGlzdGVuZXJzIiwiYyIsInNldFppbmRleCIsImV2ZW50U3RhcnQiLCJjaGlsZHJlbiIsInN0b3BQcm9wYWdhdGlvbiIsIm1vdmVFdmVudCIsImVuZEV2ZW50Iiwib3V0RXZlbnQiLCJjb25jYXQiLCJnZXRDb21wdXRlZFN0eWxlIiwiZXZlbnRUYXAiLCJldmVudEhvdmVyIiwiYmluZFNsaWRlckV2ZW50cyIsImJlaGF2aW91ciIsImhhbmRsZUJlZm9yZSIsImhhbmRsZUFmdGVyIiwiZXZlbnRIb2xkZXJzIiwiZXZlbnRIb2xkZXIiLCJyZWZlcmVuY2UiLCJsb29rQmFja3dhcmQiLCJsb29rRm9yd2FyZCIsInRvUGN0IiwicGN0IiwidXBkYXRlSGFuZGxlUG9zaXRpb24iLCJzdGF0ZVVwZGF0ZSIsInVwZGF0ZUNvbm5lY3QiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ6SW5kZXgiLCJjaGlsZE5vZGVzIiwibCIsImgiLCJzZXRWYWx1ZSIsInZhbHVlU2V0IiwiaW5wdXQiLCJmaXJlU2V0RXZlbnQiLCJpc0luaXQiLCJ2YWx1ZVJlc2V0IiwidmFsdWVHZXQiLCJkZXN0cm95IiwicmVtb3ZlQ2hpbGQiLCJnZXRDdXJyZW50U3RlcCIsIm5lYXJieVN0ZXBzIiwiZGVjcmVtZW50IiwibmFtZXNwYWNlZEV2ZW50IiwicmVtb3ZlRXZlbnQiLCJuYW1lc3BhY2UiLCJzdWJzdHJpbmciLCJiaW5kIiwidEV2ZW50IiwidE5hbWVzcGFjZSIsInVwZGF0ZU9wdGlvbnMiLCJvcHRpb25zVG9VcGRhdGUiLCJ1cGRhdGVBYmxlIiwibmV3T3B0aW9ucyIsIm9uIiwib2ZmIiwiZ2V0Iiwic2V0IiwicmVzZXQiLCJfX21vdmVIYW5kbGVzIiwiaW5pdGlhbGl6ZSIsImFwaSIsInZlcnNpb24iLCJjcmVhdGUiXSwibWFwcGluZ3MiOiI7O0FBQUE7O0FBRUMsV0FBVUEsT0FBVixFQUFtQjs7QUFFaEIsS0FBSyxJQUFMLEVBQWtEOztBQUU5QztBQUNBQyxFQUFBLGlDQUFPLEVBQVAsb0NBQVdELE9BQVg7QUFBQTtBQUFBO0FBQUE7QUFFSCxFQUxELE1BS08sSUFBSyxRQUFPRSxPQUFQLHlDQUFPQSxPQUFQLE9BQW1CLFFBQXhCLEVBQW1DOztBQUV0QztBQUNBQyxTQUFPRCxPQUFQLEdBQWlCRixTQUFqQjtBQUVILEVBTE0sTUFLQTs7QUFFSDtBQUNBSSxTQUFPQyxVQUFQLEdBQW9CTCxTQUFwQjtBQUNIO0FBRUosQ0FsQkEsRUFrQkMsWUFBVzs7QUFFWjs7QUFFQSxLQUFJTSxVQUFVLE9BQWQ7O0FBR0E7QUFDQSxVQUFTQyxTQUFULENBQXFCQyxNQUFyQixFQUE2QkMsU0FBN0IsRUFBeUM7QUFDeEMsTUFBSUMs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QUFlLHVCQUFTcFosQ0FBVCxFQUFZMkYsQ0FBWixFQUFlOFAsQ0FBZixFQUFrQjtBQUFFM0IsZ0JBQVk5VCxDQUFaLEVBQWUyRixDQUFmLEVBQWtCK0gsZUFBbEIsRUFBbUMrSCxDQUFuQztBQUF3QyxJQVQvRDtBQVVaeEssWUFBU3NDLGVBVkcsRUFVYztBQUMxQm9MLGtCQUFlQSxhQVhIO0FBWVpyWixXQUFRbU8sWUFaSSxFQVlVO0FBQ3RCdEIsU0FBTUEsSUFiTSxDQWFEO0FBYkMsR0FBYjs7QUFnQkE7QUFDQWtLLG1CQUFpQnBMLFFBQVFoQixNQUF6Qjs7QUFFQTtBQUNBd04sV0FBU3hNLFFBQVEvRyxLQUFqQjs7QUFFQSxNQUFLK0csUUFBUWtCLElBQWIsRUFBb0I7QUFDbkJBLFFBQUtsQixRQUFRa0IsSUFBYjtBQUNBOztBQUVELE1BQUtsQixRQUFRZCxRQUFiLEVBQXdCO0FBQ3ZCQTtBQUNBOztBQUVELFNBQU9nRSxVQUFQO0FBRUE7O0FBR0E7QUFDQSxVQUFTa0wsVUFBVCxDQUFzQi9aLE1BQXRCLEVBQThCaU8sZUFBOUIsRUFBZ0Q7O0FBRS9DLE1BQUssQ0FBQ2pPLE9BQU93VixRQUFiLEVBQXdCO0FBQ3ZCLFNBQU0sSUFBSTFPLEtBQUosQ0FBVSxpQkFBaUJoSCxPQUFqQixHQUEyQixzQ0FBckMsQ0FBTjtBQUNBOztBQUVEO0FBQ0EsTUFBSTZMLFVBQVVELFlBQWF1QyxlQUFiLEVBQThCak8sTUFBOUIsQ0FBZDtBQUNBLE1BQUlnYSxNQUFNaE0sUUFBU2hPLE1BQVQsRUFBaUIyTCxPQUFqQixFQUEwQnNDLGVBQTFCLENBQVY7O0FBRUFqTyxTQUFPSCxVQUFQLEdBQW9CbWEsR0FBcEI7O0FBRUEsU0FBT0EsR0FBUDtBQUNBOztBQUVEO0FBQ0EsUUFBTztBQUNOQyxXQUFTbmEsT0FESDtBQUVOb2EsVUFBUUg7QUFGRixFQUFQO0FBS0EsQ0EvbEVBLENBQUQiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qISBub3Vpc2xpZGVyIC0gOS4yLjAgLSAyMDE3LTAxLTExIDEwOjM1OjM0ICovXHJcblxyXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuXHJcbiAgICBpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcclxuXHJcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxyXG4gICAgICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XHJcblxyXG4gICAgfSBlbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICkge1xyXG5cclxuICAgICAgICAvLyBOb2RlL0NvbW1vbkpTXHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XHJcblxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzXHJcbiAgICAgICAgd2luZG93Lm5vVWlTbGlkZXIgPSBmYWN0b3J5KCk7XHJcbiAgICB9XHJcblxyXG59KGZ1bmN0aW9uKCApe1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdHZhciBWRVJTSU9OID0gJzkuMi4wJztcclxuXHJcblxyXG5cdC8vIENyZWF0ZXMgYSBub2RlLCBhZGRzIGl0IHRvIHRhcmdldCwgcmV0dXJucyB0aGUgbmV3IG5vZGUuXHJcblx0ZnVuY3Rpb24gYWRkTm9kZVRvICggdGFyZ2V0LCBjbGFzc05hbWUgKSB7XHJcblx0XHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRhZGRDbGFzcyhkaXYsIGNsYXNzTmFtZSk7XHJcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoZGl2KTtcclxuXHRcdHJldHVybiBkaXY7XHJcblx0fVxyXG5cclxuXHQvLyBSZW1vdmVzIGR1cGxpY2F0ZXMgZnJvbSBhbiBhcnJheS5cclxuXHRmdW5jdGlvbiB1bmlxdWUgKCBhcnJheSApIHtcclxuXHRcdHJldHVybiBhcnJheS5maWx0ZXIoZnVuY3Rpb24oYSl7XHJcblx0XHRcdHJldHVybiAhdGhpc1thXSA/IHRoaXNbYV0gPSB0cnVlIDogZmFsc2U7XHJcblx0XHR9LCB7fSk7XHJcblx0fVxyXG5cclxuXHQvLyBSb3VuZCBhIHZhbHVlIHRvIHRoZSBjbG9zZXN0ICd0bycuXHJcblx0ZnVuY3Rpb24gY2xvc2VzdCAoIHZhbHVlLCB0byApIHtcclxuXHRcdHJldHVybiBNYXRoLnJvdW5kKHZhbHVlIC8gdG8pICogdG87XHJcblx0fVxyXG5cclxuXHQvLyBDdXJyZW50IHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50LlxyXG5cdGZ1bmN0aW9uIG9mZnNldCAoIGVsZW0sIG9yaWVudGF0aW9uICkge1xyXG5cclxuXHR2YXIgcmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXHJcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXHJcblx0XHRkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudCxcclxuXHRcdHBhZ2VPZmZzZXQgPSBnZXRQYWdlT2Zmc2V0KCk7XHJcblxyXG5cdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGNvbnRhaW5zIGxlZnQgc2Nyb2xsIGluIENocm9tZSBvbiBBbmRyb2lkLlxyXG5cdFx0Ly8gSSBoYXZlbid0IGZvdW5kIGEgZmVhdHVyZSBkZXRlY3Rpb24gdGhhdCBwcm92ZXMgdGhpcy4gV29yc3QgY2FzZVxyXG5cdFx0Ly8gc2NlbmFyaW8gb24gbWlzLW1hdGNoOiB0aGUgJ3RhcCcgZmVhdHVyZSBvbiBob3Jpem9udGFsIHNsaWRlcnMgYnJlYWtzLlxyXG5cdFx0aWYgKCAvd2Via2l0LipDaHJvbWUuKk1vYmlsZS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgKSB7XHJcblx0XHRcdHBhZ2VPZmZzZXQueCA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG9yaWVudGF0aW9uID8gKHJlY3QudG9wICsgcGFnZU9mZnNldC55IC0gZG9jRWxlbS5jbGllbnRUb3ApIDogKHJlY3QubGVmdCArIHBhZ2VPZmZzZXQueCAtIGRvY0VsZW0uY2xpZW50TGVmdCk7XHJcblx0fVxyXG5cclxuXHQvLyBDaGVja3Mgd2hldGhlciBhIHZhbHVlIGlzIG51bWVyaWNhbC5cclxuXHRmdW5jdGlvbiBpc051bWVyaWMgKCBhICkge1xyXG5cdFx0cmV0dXJuIHR5cGVvZiBhID09PSAnbnVtYmVyJyAmJiAhaXNOYU4oIGEgKSAmJiBpc0Zpbml0ZSggYSApO1xyXG5cdH1cclxuXHJcblx0Ly8gU2V0cyBhIGNsYXNzIGFuZCByZW1vdmVzIGl0IGFmdGVyIFtkdXJhdGlvbl0gbXMuXHJcblx0ZnVuY3Rpb24gYWRkQ2xhc3NGb3IgKCBlbGVtZW50LCBjbGFzc05hbWUsIGR1cmF0aW9uICkge1xyXG5cdFx0aWYgKGR1cmF0aW9uID4gMCkge1xyXG5cdFx0YWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKTtcclxuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpe1xyXG5cdFx0XHRcdHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSk7XHJcblx0XHRcdH0sIGR1cmF0aW9uKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIExpbWl0cyBhIHZhbHVlIHRvIDAgLSAxMDBcclxuXHRmdW5jdGlvbiBsaW1pdCAoIGEgKSB7XHJcblx0XHRyZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oYSwgMTAwKSwgMCk7XHJcblx0fVxyXG5cclxuXHQvLyBXcmFwcyBhIHZhcmlhYmxlIGFzIGFuIGFycmF5LCBpZiBpdCBpc24ndCBvbmUgeWV0LlxyXG5cdC8vIE5vdGUgdGhhdCBhbiBpbnB1dCBhcnJheSBpcyByZXR1cm5lZCBieSByZWZlcmVuY2UhXHJcblx0ZnVuY3Rpb24gYXNBcnJheSAoIGEgKSB7XHJcblx0XHRyZXR1cm4gQXJyYXkuaXNBcnJheShhKSA/IGEgOiBbYV07XHJcblx0fVxyXG5cclxuXHQvLyBDb3VudHMgZGVjaW1hbHNcclxuXHRmdW5jdGlvbiBjb3VudERlY2ltYWxzICggbnVtU3RyICkge1xyXG5cdFx0bnVtU3RyID0gU3RyaW5nKG51bVN0cik7XHJcblx0XHR2YXIgcGllY2VzID0gbnVtU3RyLnNwbGl0KFwiLlwiKTtcclxuXHRcdHJldHVybiBwaWVjZXMubGVuZ3RoID4gMSA/IHBpZWNlc1sxXS5sZW5ndGggOiAwO1xyXG5cdH1cclxuXHJcblx0Ly8gaHR0cDovL3lvdW1pZ2h0bm90bmVlZGpxdWVyeS5jb20vI2FkZF9jbGFzc1xyXG5cdGZ1bmN0aW9uIGFkZENsYXNzICggZWwsIGNsYXNzTmFtZSApIHtcclxuXHRcdGlmICggZWwuY2xhc3NMaXN0ICkge1xyXG5cdFx0XHRlbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRlbC5jbGFzc05hbWUgKz0gJyAnICsgY2xhc3NOYW1lO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gaHR0cDovL3lvdW1pZ2h0bm90bmVlZGpxdWVyeS5jb20vI3JlbW92ZV9jbGFzc1xyXG5cdGZ1bmN0aW9uIHJlbW92ZUNsYXNzICggZWwsIGNsYXNzTmFtZSApIHtcclxuXHRcdGlmICggZWwuY2xhc3NMaXN0ICkge1xyXG5cdFx0XHRlbC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRlbC5jbGFzc05hbWUgPSBlbC5jbGFzc05hbWUucmVwbGFjZShuZXcgUmVnRXhwKCcoXnxcXFxcYiknICsgY2xhc3NOYW1lLnNwbGl0KCcgJykuam9pbignfCcpICsgJyhcXFxcYnwkKScsICdnaScpLCAnICcpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gaHR0cHM6Ly9wbGFpbmpzLmNvbS9qYXZhc2NyaXB0L2F0dHJpYnV0ZXMvYWRkaW5nLXJlbW92aW5nLWFuZC10ZXN0aW5nLWZvci1jbGFzc2VzLTkvXHJcblx0ZnVuY3Rpb24gaGFzQ2xhc3MgKCBlbCwgY2xhc3NOYW1lICkge1xyXG5cdFx0cmV0dXJuIGVsLmNsYXNzTGlzdCA/IGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpIDogbmV3IFJlZ0V4cCgnXFxcXGInICsgY2xhc3NOYW1lICsgJ1xcXFxiJykudGVzdChlbC5jbGFzc05hbWUpO1xyXG5cdH1cclxuXHJcblx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9zY3JvbGxZI05vdGVzXHJcblx0ZnVuY3Rpb24gZ2V0UGFnZU9mZnNldCAoICkge1xyXG5cclxuXHRcdHZhciBzdXBwb3J0UGFnZU9mZnNldCA9IHdpbmRvdy5wYWdlWE9mZnNldCAhPT0gdW5kZWZpbmVkLFxyXG5cdFx0XHRpc0NTUzFDb21wYXQgPSAoKGRvY3VtZW50LmNvbXBhdE1vZGUgfHwgXCJcIikgPT09IFwiQ1NTMUNvbXBhdFwiKSxcclxuXHRcdFx0eCA9IHN1cHBvcnRQYWdlT2Zmc2V0ID8gd2luZG93LnBhZ2VYT2Zmc2V0IDogaXNDU1MxQ29tcGF0ID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgOiBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQsXHJcblx0XHRcdHkgPSBzdXBwb3J0UGFnZU9mZnNldCA/IHdpbmRvdy5wYWdlWU9mZnNldCA6IGlzQ1NTMUNvbXBhdCA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgOiBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcDtcclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR4OiB4LFxyXG5cdFx0XHR5OiB5XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0Ly8gd2UgcHJvdmlkZSBhIGZ1bmN0aW9uIHRvIGNvbXB1dGUgY29uc3RhbnRzIGluc3RlYWRcclxuXHQvLyBvZiBhY2Nlc3Npbmcgd2luZG93LiogYXMgc29vbiBhcyB0aGUgbW9kdWxlIG5lZWRzIGl0XHJcblx0Ly8gc28gdGhhdCB3ZSBkbyBub3QgY29tcHV0ZSBhbnl0aGluZyBpZiBub3QgbmVlZGVkXHJcblx0ZnVuY3Rpb24gZ2V0QWN0aW9ucyAoICkge1xyXG5cclxuXHRcdC8vIERldGVybWluZSB0aGUgZXZlbnRzIHRvIGJpbmQuIElFMTEgaW1wbGVtZW50cyBwb2ludGVyRXZlbnRzIHdpdGhvdXRcclxuXHRcdC8vIGEgcHJlZml4LCB3aGljaCBicmVha3MgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBJRTEwIGltcGxlbWVudGF0aW9uLlxyXG5cdFx0cmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgPyB7XHJcblx0XHRcdHN0YXJ0OiAncG9pbnRlcmRvd24nLFxyXG5cdFx0XHRtb3ZlOiAncG9pbnRlcm1vdmUnLFxyXG5cdFx0XHRlbmQ6ICdwb2ludGVydXAnXHJcblx0XHR9IDogd2luZG93Lm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkID8ge1xyXG5cdFx0XHRzdGFydDogJ01TUG9pbnRlckRvd24nLFxyXG5cdFx0XHRtb3ZlOiAnTVNQb2ludGVyTW92ZScsXHJcblx0XHRcdGVuZDogJ01TUG9pbnRlclVwJ1xyXG5cdFx0fSA6IHtcclxuXHRcdFx0c3RhcnQ6ICdtb3VzZWRvd24gdG91Y2hzdGFydCcsXHJcblx0XHRcdG1vdmU6ICdtb3VzZW1vdmUgdG91Y2htb3ZlJyxcclxuXHRcdFx0ZW5kOiAnbW91c2V1cCB0b3VjaGVuZCdcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHJcbi8vIFZhbHVlIGNhbGN1bGF0aW9uXHJcblxyXG5cdC8vIERldGVybWluZSB0aGUgc2l6ZSBvZiBhIHN1Yi1yYW5nZSBpbiByZWxhdGlvbiB0byBhIGZ1bGwgcmFuZ2UuXHJcblx0ZnVuY3Rpb24gc3ViUmFuZ2VSYXRpbyAoIHBhLCBwYiApIHtcclxuXHRcdHJldHVybiAoMTAwIC8gKHBiIC0gcGEpKTtcclxuXHR9XHJcblxyXG5cdC8vIChwZXJjZW50YWdlKSBIb3cgbWFueSBwZXJjZW50IGlzIHRoaXMgdmFsdWUgb2YgdGhpcyByYW5nZT9cclxuXHRmdW5jdGlvbiBmcm9tUGVyY2VudGFnZSAoIHJhbmdlLCB2YWx1ZSApIHtcclxuXHRcdHJldHVybiAodmFsdWUgKiAxMDApIC8gKCByYW5nZVsxXSAtIHJhbmdlWzBdICk7XHJcblx0fVxyXG5cclxuXHQvLyAocGVyY2VudGFnZSkgV2hlcmUgaXMgdGhpcyB2YWx1ZSBvbiB0aGlzIHJhbmdlP1xyXG5cdGZ1bmN0aW9uIHRvUGVyY2VudGFnZSAoIHJhbmdlLCB2YWx1ZSApIHtcclxuXHRcdHJldHVybiBmcm9tUGVyY2VudGFnZSggcmFuZ2UsIHJhbmdlWzBdIDwgMCA/XHJcblx0XHRcdHZhbHVlICsgTWF0aC5hYnMocmFuZ2VbMF0pIDpcclxuXHRcdFx0XHR2YWx1ZSAtIHJhbmdlWzBdICk7XHJcblx0fVxyXG5cclxuXHQvLyAodmFsdWUpIEhvdyBtdWNoIGlzIHRoaXMgcGVyY2VudGFnZSBvbiB0aGlzIHJhbmdlP1xyXG5cdGZ1bmN0aW9uIGlzUGVyY2VudGFnZSAoIHJhbmdlLCB2YWx1ZSApIHtcclxuXHRcdHJldHVybiAoKHZhbHVlICogKCByYW5nZVsxXSAtIHJhbmdlWzBdICkpIC8gMTAwKSArIHJhbmdlWzBdO1xyXG5cdH1cclxuXHJcblxyXG4vLyBSYW5nZSBjb252ZXJzaW9uXHJcblxyXG5cdGZ1bmN0aW9uIGdldEogKCB2YWx1ZSwgYXJyICkge1xyXG5cclxuXHRcdHZhciBqID0gMTtcclxuXHJcblx0XHR3aGlsZSAoIHZhbHVlID49IGFycltqXSApe1xyXG5cdFx0XHRqICs9IDE7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGo7XHJcblx0fVxyXG5cclxuXHQvLyAocGVyY2VudGFnZSkgSW5wdXQgYSB2YWx1ZSwgZmluZCB3aGVyZSwgb24gYSBzY2FsZSBvZiAwLTEwMCwgaXQgYXBwbGllcy5cclxuXHRmdW5jdGlvbiB0b1N0ZXBwaW5nICggeFZhbCwgeFBjdCwgdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCB2YWx1ZSA+PSB4VmFsLnNsaWNlKC0xKVswXSApe1xyXG5cdFx0XHRyZXR1cm4gMTAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBqID0gZ2V0SiggdmFsdWUsIHhWYWwgKSwgdmEsIHZiLCBwYSwgcGI7XHJcblxyXG5cdFx0dmEgPSB4VmFsW2otMV07XHJcblx0XHR2YiA9IHhWYWxbal07XHJcblx0XHRwYSA9IHhQY3Rbai0xXTtcclxuXHRcdHBiID0geFBjdFtqXTtcclxuXHJcblx0XHRyZXR1cm4gcGEgKyAodG9QZXJjZW50YWdlKFt2YSwgdmJdLCB2YWx1ZSkgLyBzdWJSYW5nZVJhdGlvIChwYSwgcGIpKTtcclxuXHR9XHJcblxyXG5cdC8vICh2YWx1ZSkgSW5wdXQgYSBwZXJjZW50YWdlLCBmaW5kIHdoZXJlIGl0IGlzIG9uIHRoZSBzcGVjaWZpZWQgcmFuZ2UuXHJcblx0ZnVuY3Rpb24gZnJvbVN0ZXBwaW5nICggeFZhbCwgeFBjdCwgdmFsdWUgKSB7XHJcblxyXG5cdFx0Ly8gVGhlcmUgaXMgbm8gcmFuZ2UgZ3JvdXAgdGhhdCBmaXRzIDEwMFxyXG5cdFx0aWYgKCB2YWx1ZSA+PSAxMDAgKXtcclxuXHRcdFx0cmV0dXJuIHhWYWwuc2xpY2UoLTEpWzBdO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBqID0gZ2V0SiggdmFsdWUsIHhQY3QgKSwgdmEsIHZiLCBwYSwgcGI7XHJcblxyXG5cdFx0dmEgPSB4VmFsW2otMV07XHJcblx0XHR2YiA9IHhWYWxbal07XHJcblx0XHRwYSA9IHhQY3Rbai0xXTtcclxuXHRcdHBiID0geFBjdFtqXTtcclxuXHJcblx0XHRyZXR1cm4gaXNQZXJjZW50YWdlKFt2YSwgdmJdLCAodmFsdWUgLSBwYSkgKiBzdWJSYW5nZVJhdGlvIChwYSwgcGIpKTtcclxuXHR9XHJcblxyXG5cdC8vIChwZXJjZW50YWdlKSBHZXQgdGhlIHN0ZXAgdGhhdCBhcHBsaWVzIGF0IGEgY2VydGFpbiB2YWx1ZS5cclxuXHRmdW5jdGlvbiBnZXRTdGVwICggeFBjdCwgeFN0ZXBzLCBzbmFwLCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIHZhbHVlID09PSAxMDAgKSB7XHJcblx0XHRcdHJldHVybiB2YWx1ZTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaiA9IGdldEooIHZhbHVlLCB4UGN0ICksIGEsIGI7XHJcblxyXG5cdFx0Ly8gSWYgJ3NuYXAnIGlzIHNldCwgc3RlcHMgYXJlIHVzZWQgYXMgZml4ZWQgcG9pbnRzIG9uIHRoZSBzbGlkZXIuXHJcblx0XHRpZiAoIHNuYXAgKSB7XHJcblxyXG5cdFx0XHRhID0geFBjdFtqLTFdO1xyXG5cdFx0XHRiID0geFBjdFtqXTtcclxuXHJcblx0XHRcdC8vIEZpbmQgdGhlIGNsb3Nlc3QgcG9zaXRpb24sIGEgb3IgYi5cclxuXHRcdFx0aWYgKCh2YWx1ZSAtIGEpID4gKChiLWEpLzIpKXtcclxuXHRcdFx0XHRyZXR1cm4gYjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGE7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCAheFN0ZXBzW2otMV0gKXtcclxuXHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB4UGN0W2otMV0gKyBjbG9zZXN0KFxyXG5cdFx0XHR2YWx1ZSAtIHhQY3Rbai0xXSxcclxuXHRcdFx0eFN0ZXBzW2otMV1cclxuXHRcdCk7XHJcblx0fVxyXG5cclxuXHJcbi8vIEVudHJ5IHBhcnNpbmdcclxuXHJcblx0ZnVuY3Rpb24gaGFuZGxlRW50cnlQb2ludCAoIGluZGV4LCB2YWx1ZSwgdGhhdCApIHtcclxuXHJcblx0XHR2YXIgcGVyY2VudGFnZTtcclxuXHJcblx0XHQvLyBXcmFwIG51bWVyaWNhbCBpbnB1dCBpbiBhbiBhcnJheS5cclxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICkge1xyXG5cdFx0XHR2YWx1ZSA9IFt2YWx1ZV07XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gUmVqZWN0IGFueSBpbnZhbGlkIGlucHV0LCBieSB0ZXN0aW5nIHdoZXRoZXIgdmFsdWUgaXMgYW4gYXJyYXkuXHJcblx0XHRpZiAoIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCggdmFsdWUgKSAhPT0gJ1tvYmplY3QgQXJyYXldJyApe1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdyYW5nZScgY29udGFpbnMgaW52YWxpZCB2YWx1ZS5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ292ZXJ0IG1pbi9tYXggc3ludGF4IHRvIDAgYW5kIDEwMC5cclxuXHRcdGlmICggaW5kZXggPT09ICdtaW4nICkge1xyXG5cdFx0XHRwZXJjZW50YWdlID0gMDtcclxuXHRcdH0gZWxzZSBpZiAoIGluZGV4ID09PSAnbWF4JyApIHtcclxuXHRcdFx0cGVyY2VudGFnZSA9IDEwMDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHBlcmNlbnRhZ2UgPSBwYXJzZUZsb2F0KCBpbmRleCApO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENoZWNrIGZvciBjb3JyZWN0IGlucHV0LlxyXG5cdFx0aWYgKCAhaXNOdW1lcmljKCBwZXJjZW50YWdlICkgfHwgIWlzTnVtZXJpYyggdmFsdWVbMF0gKSApIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAncmFuZ2UnIHZhbHVlIGlzbid0IG51bWVyaWMuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFN0b3JlIHZhbHVlcy5cclxuXHRcdHRoYXQueFBjdC5wdXNoKCBwZXJjZW50YWdlICk7XHJcblx0XHR0aGF0LnhWYWwucHVzaCggdmFsdWVbMF0gKTtcclxuXHJcblx0XHQvLyBOYU4gd2lsbCBldmFsdWF0ZSB0byBmYWxzZSB0b28sIGJ1dCB0byBrZWVwXHJcblx0XHQvLyBsb2dnaW5nIGNsZWFyLCBzZXQgc3RlcCBleHBsaWNpdGx5LiBNYWtlIHN1cmVcclxuXHRcdC8vIG5vdCB0byBvdmVycmlkZSB0aGUgJ3N0ZXAnIHNldHRpbmcgd2l0aCBmYWxzZS5cclxuXHRcdGlmICggIXBlcmNlbnRhZ2UgKSB7XHJcblx0XHRcdGlmICggIWlzTmFOKCB2YWx1ZVsxXSApICkge1xyXG5cdFx0XHRcdHRoYXQueFN0ZXBzWzBdID0gdmFsdWVbMV07XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoYXQueFN0ZXBzLnB1c2goIGlzTmFOKHZhbHVlWzFdKSA/IGZhbHNlIDogdmFsdWVbMV0gKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGF0LnhIaWdoZXN0Q29tcGxldGVTdGVwLnB1c2goMCk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBoYW5kbGVTdGVwUG9pbnQgKCBpLCBuLCB0aGF0ICkge1xyXG5cclxuXHRcdC8vIElnbm9yZSAnZmFsc2UnIHN0ZXBwaW5nLlxyXG5cdFx0aWYgKCAhbiApIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRmFjdG9yIHRvIHJhbmdlIHJhdGlvXHJcblx0XHR0aGF0LnhTdGVwc1tpXSA9IGZyb21QZXJjZW50YWdlKFtcclxuXHRcdFx0IHRoYXQueFZhbFtpXVxyXG5cdFx0XHQsdGhhdC54VmFsW2krMV1cclxuXHRcdF0sIG4pIC8gc3ViUmFuZ2VSYXRpbyAoXHJcblx0XHRcdHRoYXQueFBjdFtpXSxcclxuXHRcdFx0dGhhdC54UGN0W2krMV0gKTtcclxuXHJcblx0XHR2YXIgdG90YWxTdGVwcyA9ICh0aGF0LnhWYWxbaSsxXSAtIHRoYXQueFZhbFtpXSkgLyB0aGF0LnhOdW1TdGVwc1tpXTtcclxuXHRcdHZhciBoaWdoZXN0U3RlcCA9IE1hdGguY2VpbChOdW1iZXIodG90YWxTdGVwcy50b0ZpeGVkKDMpKSAtIDEpO1xyXG5cdFx0dmFyIHN0ZXAgPSB0aGF0LnhWYWxbaV0gKyAodGhhdC54TnVtU3RlcHNbaV0gKiBoaWdoZXN0U3RlcCk7XHJcblxyXG5cdFx0dGhhdC54SGlnaGVzdENvbXBsZXRlU3RlcFtpXSA9IHN0ZXA7XHJcblx0fVxyXG5cclxuXHJcbi8vIEludGVyZmFjZVxyXG5cclxuXHQvLyBUaGUgaW50ZXJmYWNlIHRvIFNwZWN0cnVtIGhhbmRsZXMgYWxsIGRpcmVjdGlvbi1iYXNlZFxyXG5cdC8vIGNvbnZlcnNpb25zLCBzbyB0aGUgYWJvdmUgdmFsdWVzIGFyZSB1bmF3YXJlLlxyXG5cclxuXHRmdW5jdGlvbiBTcGVjdHJ1bSAoIGVudHJ5LCBzbmFwLCBkaXJlY3Rpb24sIHNpbmdsZVN0ZXAgKSB7XHJcblxyXG5cdFx0dGhpcy54UGN0ID0gW107XHJcblx0XHR0aGlzLnhWYWwgPSBbXTtcclxuXHRcdHRoaXMueFN0ZXBzID0gWyBzaW5nbGVTdGVwIHx8IGZhbHNlIF07XHJcblx0XHR0aGlzLnhOdW1TdGVwcyA9IFsgZmFsc2UgXTtcclxuXHRcdHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXAgPSBbXTtcclxuXHJcblx0XHR0aGlzLnNuYXAgPSBzbmFwO1xyXG5cdFx0dGhpcy5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XHJcblxyXG5cdFx0dmFyIGluZGV4LCBvcmRlcmVkID0gWyAvKiBbMCwgJ21pbiddLCBbMSwgJzUwJSddLCBbMiwgJ21heCddICovIF07XHJcblxyXG5cdFx0Ly8gTWFwIHRoZSBvYmplY3Qga2V5cyB0byBhbiBhcnJheS5cclxuXHRcdGZvciAoIGluZGV4IGluIGVudHJ5ICkge1xyXG5cdFx0XHRpZiAoIGVudHJ5Lmhhc093blByb3BlcnR5KGluZGV4KSApIHtcclxuXHRcdFx0XHRvcmRlcmVkLnB1c2goW2VudHJ5W2luZGV4XSwgaW5kZXhdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNvcnQgYWxsIGVudHJpZXMgYnkgdmFsdWUgKG51bWVyaWMgc29ydCkuXHJcblx0XHRpZiAoIG9yZGVyZWQubGVuZ3RoICYmIHR5cGVvZiBvcmRlcmVkWzBdWzBdID09PSBcIm9iamVjdFwiICkge1xyXG5cdFx0XHRvcmRlcmVkLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYVswXVswXSAtIGJbMF1bMF07IH0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b3JkZXJlZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGFbMF0gLSBiWzBdOyB9KTtcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0Ly8gQ29udmVydCBhbGwgZW50cmllcyB0byBzdWJyYW5nZXMuXHJcblx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgb3JkZXJlZC5sZW5ndGg7IGluZGV4KysgKSB7XHJcblx0XHRcdGhhbmRsZUVudHJ5UG9pbnQob3JkZXJlZFtpbmRleF1bMV0sIG9yZGVyZWRbaW5kZXhdWzBdLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBTdG9yZSB0aGUgYWN0dWFsIHN0ZXAgdmFsdWVzLlxyXG5cdFx0Ly8geFN0ZXBzIGlzIHNvcnRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB4UGN0IGFuZCB4VmFsLlxyXG5cdFx0dGhpcy54TnVtU3RlcHMgPSB0aGlzLnhTdGVwcy5zbGljZSgwKTtcclxuXHJcblx0XHQvLyBDb252ZXJ0IGFsbCBudW1lcmljIHN0ZXBzIHRvIHRoZSBwZXJjZW50YWdlIG9mIHRoZSBzdWJyYW5nZSB0aGV5IHJlcHJlc2VudC5cclxuXHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnhOdW1TdGVwcy5sZW5ndGg7IGluZGV4KysgKSB7XHJcblx0XHRcdGhhbmRsZVN0ZXBQb2ludChpbmRleCwgdGhpcy54TnVtU3RlcHNbaW5kZXhdLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdFNwZWN0cnVtLnByb3RvdHlwZS5nZXRNYXJnaW4gPSBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHZhciBzdGVwID0gdGhpcy54TnVtU3RlcHNbMF07XHJcblxyXG5cdFx0aWYgKCBzdGVwICYmICgodmFsdWUgLyBzdGVwKSAlIDEpICE9PSAwICkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdsaW1pdCcsICdtYXJnaW4nIGFuZCAncGFkZGluZycgbXVzdCBiZSBkaXZpc2libGUgYnkgc3RlcC5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMueFBjdC5sZW5ndGggPT09IDIgPyBmcm9tUGVyY2VudGFnZSh0aGlzLnhWYWwsIHZhbHVlKSA6IGZhbHNlO1xyXG5cdH07XHJcblxyXG5cdFNwZWN0cnVtLnByb3RvdHlwZS50b1N0ZXBwaW5nID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR2YWx1ZSA9IHRvU3RlcHBpbmcoIHRoaXMueFZhbCwgdGhpcy54UGN0LCB2YWx1ZSApO1xyXG5cclxuXHRcdHJldHVybiB2YWx1ZTtcclxuXHR9O1xyXG5cclxuXHRTcGVjdHJ1bS5wcm90b3R5cGUuZnJvbVN0ZXBwaW5nID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRyZXR1cm4gZnJvbVN0ZXBwaW5nKCB0aGlzLnhWYWwsIHRoaXMueFBjdCwgdmFsdWUgKTtcclxuXHR9O1xyXG5cclxuXHRTcGVjdHJ1bS5wcm90b3R5cGUuZ2V0U3RlcCA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dmFsdWUgPSBnZXRTdGVwKHRoaXMueFBjdCwgdGhpcy54U3RlcHMsIHRoaXMuc25hcCwgdmFsdWUgKTtcclxuXHJcblx0XHRyZXR1cm4gdmFsdWU7XHJcblx0fTtcclxuXHJcblx0U3BlY3RydW0ucHJvdG90eXBlLmdldE5lYXJieVN0ZXBzID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR2YXIgaiA9IGdldEoodmFsdWUsIHRoaXMueFBjdCk7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0c3RlcEJlZm9yZTogeyBzdGFydFZhbHVlOiB0aGlzLnhWYWxbai0yXSwgc3RlcDogdGhpcy54TnVtU3RlcHNbai0yXSwgaGlnaGVzdFN0ZXA6IHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbai0yXSB9LFxyXG5cdFx0XHR0aGlzU3RlcDogeyBzdGFydFZhbHVlOiB0aGlzLnhWYWxbai0xXSwgc3RlcDogdGhpcy54TnVtU3RlcHNbai0xXSwgaGlnaGVzdFN0ZXA6IHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbai0xXSB9LFxyXG5cdFx0XHRzdGVwQWZ0ZXI6IHsgc3RhcnRWYWx1ZTogdGhpcy54VmFsW2otMF0sIHN0ZXA6IHRoaXMueE51bVN0ZXBzW2otMF0sIGhpZ2hlc3RTdGVwOiB0aGlzLnhIaWdoZXN0Q29tcGxldGVTdGVwW2otMF0gfVxyXG5cdFx0fTtcclxuXHR9O1xyXG5cclxuXHRTcGVjdHJ1bS5wcm90b3R5cGUuY291bnRTdGVwRGVjaW1hbHMgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc3RlcERlY2ltYWxzID0gdGhpcy54TnVtU3RlcHMubWFwKGNvdW50RGVjaW1hbHMpO1xyXG5cdFx0cmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIHN0ZXBEZWNpbWFscyk7XHJcbiBcdH07XHJcblxyXG5cdC8vIE91dHNpZGUgdGVzdGluZ1xyXG5cdFNwZWN0cnVtLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFN0ZXAodGhpcy50b1N0ZXBwaW5nKHZhbHVlKSk7XHJcblx0fTtcclxuXHJcbi8qXHRFdmVyeSBpbnB1dCBvcHRpb24gaXMgdGVzdGVkIGFuZCBwYXJzZWQuIFRoaXMnbGwgcHJldmVudFxyXG5cdGVuZGxlc3MgdmFsaWRhdGlvbiBpbiBpbnRlcm5hbCBtZXRob2RzLiBUaGVzZSB0ZXN0cyBhcmVcclxuXHRzdHJ1Y3R1cmVkIHdpdGggYW4gaXRlbSBmb3IgZXZlcnkgb3B0aW9uIGF2YWlsYWJsZS4gQW5cclxuXHRvcHRpb24gY2FuIGJlIG1hcmtlZCBhcyByZXF1aXJlZCBieSBzZXR0aW5nIHRoZSAncicgZmxhZy5cclxuXHRUaGUgdGVzdGluZyBmdW5jdGlvbiBpcyBwcm92aWRlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcclxuXHRcdC0gVGhlIHByb3ZpZGVkIHZhbHVlIGZvciB0aGUgb3B0aW9uO1xyXG5cdFx0LSBBIHJlZmVyZW5jZSB0byB0aGUgb3B0aW9ucyBvYmplY3Q7XHJcblx0XHQtIFRoZSBuYW1lIGZvciB0aGUgb3B0aW9uO1xyXG5cclxuXHRUaGUgdGVzdGluZyBmdW5jdGlvbiByZXR1cm5zIGZhbHNlIHdoZW4gYW4gZXJyb3IgaXMgZGV0ZWN0ZWQsXHJcblx0b3IgdHJ1ZSB3aGVuIGV2ZXJ5dGhpbmcgaXMgT0suIEl0IGNhbiBhbHNvIG1vZGlmeSB0aGUgb3B0aW9uXHJcblx0b2JqZWN0LCB0byBtYWtlIHN1cmUgYWxsIHZhbHVlcyBjYW4gYmUgY29ycmVjdGx5IGxvb3BlZCBlbHNld2hlcmUuICovXHJcblxyXG5cdHZhciBkZWZhdWx0Rm9ybWF0dGVyID0geyAndG8nOiBmdW5jdGlvbiggdmFsdWUgKXtcclxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLnRvRml4ZWQoMik7XHJcblx0fSwgJ2Zyb20nOiBOdW1iZXIgfTtcclxuXHJcblx0ZnVuY3Rpb24gdGVzdFN0ZXAgKCBwYXJzZWQsIGVudHJ5ICkge1xyXG5cclxuXHRcdGlmICggIWlzTnVtZXJpYyggZW50cnkgKSApIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnc3RlcCcgaXMgbm90IG51bWVyaWMuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRoZSBzdGVwIG9wdGlvbiBjYW4gc3RpbGwgYmUgdXNlZCB0byBzZXQgc3RlcHBpbmdcclxuXHRcdC8vIGZvciBsaW5lYXIgc2xpZGVycy4gT3ZlcndyaXR0ZW4gaWYgc2V0IGluICdyYW5nZScuXHJcblx0XHRwYXJzZWQuc2luZ2xlU3RlcCA9IGVudHJ5O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdGVzdFJhbmdlICggcGFyc2VkLCBlbnRyeSApIHtcclxuXHJcblx0XHQvLyBGaWx0ZXIgaW5jb3JyZWN0IGlucHV0LlxyXG5cdFx0aWYgKCB0eXBlb2YgZW50cnkgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkoZW50cnkpICkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdyYW5nZScgaXMgbm90IGFuIG9iamVjdC5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ2F0Y2ggbWlzc2luZyBzdGFydCBvciBlbmQuXHJcblx0XHRpZiAoIGVudHJ5Lm1pbiA9PT0gdW5kZWZpbmVkIHx8IGVudHJ5Lm1heCA9PT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6IE1pc3NpbmcgJ21pbicgb3IgJ21heCcgaW4gJ3JhbmdlJy5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ2F0Y2ggZXF1YWwgc3RhcnQgb3IgZW5kLlxyXG5cdFx0aWYgKCBlbnRyeS5taW4gPT09IGVudHJ5Lm1heCApIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAncmFuZ2UnICdtaW4nIGFuZCAnbWF4JyBjYW5ub3QgYmUgZXF1YWwuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHBhcnNlZC5zcGVjdHJ1bSA9IG5ldyBTcGVjdHJ1bShlbnRyeSwgcGFyc2VkLnNuYXAsIHBhcnNlZC5kaXIsIHBhcnNlZC5zaW5nbGVTdGVwKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3RTdGFydCAoIHBhcnNlZCwgZW50cnkgKSB7XHJcblxyXG5cdFx0ZW50cnkgPSBhc0FycmF5KGVudHJ5KTtcclxuXHJcblx0XHQvLyBWYWxpZGF0ZSBpbnB1dC4gVmFsdWVzIGFyZW4ndCB0ZXN0ZWQsIGFzIHRoZSBwdWJsaWMgLnZhbCBtZXRob2RcclxuXHRcdC8vIHdpbGwgYWx3YXlzIHByb3ZpZGUgYSB2YWxpZCBsb2NhdGlvbi5cclxuXHRcdGlmICggIUFycmF5LmlzQXJyYXkoIGVudHJ5ICkgfHwgIWVudHJ5Lmxlbmd0aCApIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnc3RhcnQnIG9wdGlvbiBpcyBpbmNvcnJlY3QuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFN0b3JlIHRoZSBudW1iZXIgb2YgaGFuZGxlcy5cclxuXHRcdHBhcnNlZC5oYW5kbGVzID0gZW50cnkubGVuZ3RoO1xyXG5cclxuXHRcdC8vIFdoZW4gdGhlIHNsaWRlciBpcyBpbml0aWFsaXplZCwgdGhlIC52YWwgbWV0aG9kIHdpbGxcclxuXHRcdC8vIGJlIGNhbGxlZCB3aXRoIHRoZSBzdGFydCBvcHRpb25zLlxyXG5cdFx0cGFyc2VkLnN0YXJ0ID0gZW50cnk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB0ZXN0U25hcCAoIHBhcnNlZCwgZW50cnkgKSB7XHJcblxyXG5cdFx0Ly8gRW5mb3JjZSAxMDAlIHN0ZXBwaW5nIHdpdGhpbiBzdWJyYW5nZXMuXHJcblx0XHRwYXJzZWQuc25hcCA9IGVudHJ5O1xyXG5cclxuXHRcdGlmICggdHlwZW9mIGVudHJ5ICE9PSAnYm9vbGVhbicgKXtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnc25hcCcgb3B0aW9uIG11c3QgYmUgYSBib29sZWFuLlwiKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3RBbmltYXRlICggcGFyc2VkLCBlbnRyeSApIHtcclxuXHJcblx0XHQvLyBFbmZvcmNlIDEwMCUgc3RlcHBpbmcgd2l0aGluIHN1YnJhbmdlcy5cclxuXHRcdHBhcnNlZC5hbmltYXRlID0gZW50cnk7XHJcblxyXG5cdFx0aWYgKCB0eXBlb2YgZW50cnkgIT09ICdib29sZWFuJyApe1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdhbmltYXRlJyBvcHRpb24gbXVzdCBiZSBhIGJvb2xlYW4uXCIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdGVzdEFuaW1hdGlvbkR1cmF0aW9uICggcGFyc2VkLCBlbnRyeSApIHtcclxuXHJcblx0XHRwYXJzZWQuYW5pbWF0aW9uRHVyYXRpb24gPSBlbnRyeTtcclxuXHJcblx0XHRpZiAoIHR5cGVvZiBlbnRyeSAhPT0gJ251bWJlcicgKXtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnYW5pbWF0aW9uRHVyYXRpb24nIG9wdGlvbiBtdXN0IGJlIGEgbnVtYmVyLlwiKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3RDb25uZWN0ICggcGFyc2VkLCBlbnRyeSApIHtcclxuXHJcblx0XHR2YXIgY29ubmVjdCA9IFtmYWxzZV07XHJcblx0XHR2YXIgaTtcclxuXHJcblx0XHQvLyBNYXAgbGVnYWN5IG9wdGlvbnNcclxuXHRcdGlmICggZW50cnkgPT09ICdsb3dlcicgKSB7XHJcblx0XHRcdGVudHJ5ID0gW3RydWUsIGZhbHNlXTtcclxuXHRcdH1cclxuXHJcblx0XHRlbHNlIGlmICggZW50cnkgPT09ICd1cHBlcicgKSB7XHJcblx0XHRcdGVudHJ5ID0gW2ZhbHNlLCB0cnVlXTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBIYW5kbGUgYm9vbGVhbiBvcHRpb25zXHJcblx0XHRpZiAoIGVudHJ5ID09PSB0cnVlIHx8IGVudHJ5ID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAxOyBpIDwgcGFyc2VkLmhhbmRsZXM7IGkrKyApIHtcclxuXHRcdFx0XHRjb25uZWN0LnB1c2goZW50cnkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25uZWN0LnB1c2goZmFsc2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFJlamVjdCBpbnZhbGlkIGlucHV0XHJcblx0XHRlbHNlIGlmICggIUFycmF5LmlzQXJyYXkoIGVudHJ5ICkgfHwgIWVudHJ5Lmxlbmd0aCB8fCBlbnRyeS5sZW5ndGggIT09IHBhcnNlZC5oYW5kbGVzICsgMSApIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnY29ubmVjdCcgb3B0aW9uIGRvZXNuJ3QgbWF0Y2ggaGFuZGxlIGNvdW50LlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRlbHNlIHtcclxuXHRcdFx0Y29ubmVjdCA9IGVudHJ5O1xyXG5cdFx0fVxyXG5cclxuXHRcdHBhcnNlZC5jb25uZWN0ID0gY29ubmVjdDtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3RPcmllbnRhdGlvbiAoIHBhcnNlZCwgZW50cnkgKSB7XHJcblxyXG5cdFx0Ly8gU2V0IG9yaWVudGF0aW9uIHRvIGFuIGEgbnVtZXJpY2FsIHZhbHVlIGZvciBlYXN5XHJcblx0XHQvLyBhcnJheSBzZWxlY3Rpb24uXHJcblx0XHRzd2l0Y2ggKCBlbnRyeSApe1xyXG5cdFx0ICBjYXNlICdob3Jpem9udGFsJzpcclxuXHRcdFx0cGFyc2VkLm9ydCA9IDA7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0ICBjYXNlICd2ZXJ0aWNhbCc6XHJcblx0XHRcdHBhcnNlZC5vcnQgPSAxO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdCAgZGVmYXVsdDpcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnb3JpZW50YXRpb24nIG9wdGlvbiBpcyBpbnZhbGlkLlwiKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3RNYXJnaW4gKCBwYXJzZWQsIGVudHJ5ICkge1xyXG5cclxuXHRcdGlmICggIWlzTnVtZXJpYyhlbnRyeSkgKXtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnbWFyZ2luJyBvcHRpb24gbXVzdCBiZSBudW1lcmljLlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJc3N1ZSAjNTgyXHJcblx0XHRpZiAoIGVudHJ5ID09PSAwICkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0cGFyc2VkLm1hcmdpbiA9IHBhcnNlZC5zcGVjdHJ1bS5nZXRNYXJnaW4oZW50cnkpO1xyXG5cclxuXHRcdGlmICggIXBhcnNlZC5tYXJnaW4gKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ21hcmdpbicgb3B0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIG9uIGxpbmVhciBzbGlkZXJzLlwiKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3RMaW1pdCAoIHBhcnNlZCwgZW50cnkgKSB7XHJcblxyXG5cdFx0aWYgKCAhaXNOdW1lcmljKGVudHJ5KSApe1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdsaW1pdCcgb3B0aW9uIG11c3QgYmUgbnVtZXJpYy5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0cGFyc2VkLmxpbWl0ID0gcGFyc2VkLnNwZWN0cnVtLmdldE1hcmdpbihlbnRyeSk7XHJcblxyXG5cdFx0aWYgKCAhcGFyc2VkLmxpbWl0IHx8IHBhcnNlZC5oYW5kbGVzIDwgMiApIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnbGltaXQnIG9wdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBvbiBsaW5lYXIgc2xpZGVycyB3aXRoIDIgb3IgbW9yZSBoYW5kbGVzLlwiKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3RQYWRkaW5nICggcGFyc2VkLCBlbnRyeSApIHtcclxuXHJcblx0XHRpZiAoICFpc051bWVyaWMoZW50cnkpICl7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3BhZGRpbmcnIG9wdGlvbiBtdXN0IGJlIG51bWVyaWMuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZW50cnkgPT09IDAgKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRwYXJzZWQucGFkZGluZyA9IHBhcnNlZC5zcGVjdHJ1bS5nZXRNYXJnaW4oZW50cnkpO1xyXG5cclxuXHRcdGlmICggIXBhcnNlZC5wYWRkaW5nICkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdwYWRkaW5nJyBvcHRpb24gaXMgb25seSBzdXBwb3J0ZWQgb24gbGluZWFyIHNsaWRlcnMuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcGFyc2VkLnBhZGRpbmcgPCAwICkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdwYWRkaW5nJyBvcHRpb24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlci5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBwYXJzZWQucGFkZGluZyA+PSA1MCApIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAncGFkZGluZycgb3B0aW9uIG11c3QgYmUgbGVzcyB0aGFuIGhhbGYgdGhlIHJhbmdlLlwiKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3REaXJlY3Rpb24gKCBwYXJzZWQsIGVudHJ5ICkge1xyXG5cclxuXHRcdC8vIFNldCBkaXJlY3Rpb24gYXMgYSBudW1lcmljYWwgdmFsdWUgZm9yIGVhc3kgcGFyc2luZy5cclxuXHRcdC8vIEludmVydCBjb25uZWN0aW9uIGZvciBSVEwgc2xpZGVycywgc28gdGhhdCB0aGUgcHJvcGVyXHJcblx0XHQvLyBoYW5kbGVzIGdldCB0aGUgY29ubmVjdC9iYWNrZ3JvdW5kIGNsYXNzZXMuXHJcblx0XHRzd2l0Y2ggKCBlbnRyeSApIHtcclxuXHRcdCAgY2FzZSAnbHRyJzpcclxuXHRcdFx0cGFyc2VkLmRpciA9IDA7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0ICBjYXNlICdydGwnOlxyXG5cdFx0XHRwYXJzZWQuZGlyID0gMTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHQgIGRlZmF1bHQ6XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ2RpcmVjdGlvbicgb3B0aW9uIHdhcyBub3QgcmVjb2duaXplZC5cIik7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB0ZXN0QmVoYXZpb3VyICggcGFyc2VkLCBlbnRyeSApIHtcclxuXHJcblx0XHQvLyBNYWtlIHN1cmUgdGhlIGlucHV0IGlzIGEgc3RyaW5nLlxyXG5cdFx0aWYgKCB0eXBlb2YgZW50cnkgIT09ICdzdHJpbmcnICkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdiZWhhdmlvdXInIG11c3QgYmUgYSBzdHJpbmcgY29udGFpbmluZyBvcHRpb25zLlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBDaGVjayBpZiB0aGUgc3RyaW5nIGNvbnRhaW5zIGFueSBrZXl3b3Jkcy5cclxuXHRcdC8vIE5vbmUgYXJlIHJlcXVpcmVkLlxyXG5cdFx0dmFyIHRhcCA9IGVudHJ5LmluZGV4T2YoJ3RhcCcpID49IDA7XHJcblx0XHR2YXIgZHJhZyA9IGVudHJ5LmluZGV4T2YoJ2RyYWcnKSA+PSAwO1xyXG5cdFx0dmFyIGZpeGVkID0gZW50cnkuaW5kZXhPZignZml4ZWQnKSA+PSAwO1xyXG5cdFx0dmFyIHNuYXAgPSBlbnRyeS5pbmRleE9mKCdzbmFwJykgPj0gMDtcclxuXHRcdHZhciBob3ZlciA9IGVudHJ5LmluZGV4T2YoJ2hvdmVyJykgPj0gMDtcclxuXHJcblx0XHRpZiAoIGZpeGVkICkge1xyXG5cclxuXHRcdFx0aWYgKCBwYXJzZWQuaGFuZGxlcyAhPT0gMiApIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdmaXhlZCcgYmVoYXZpb3VyIG11c3QgYmUgdXNlZCB3aXRoIDIgaGFuZGxlc1wiKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gVXNlIG1hcmdpbiB0byBlbmZvcmNlIGZpeGVkIHN0YXRlXHJcblx0XHRcdHRlc3RNYXJnaW4ocGFyc2VkLCBwYXJzZWQuc3RhcnRbMV0gLSBwYXJzZWQuc3RhcnRbMF0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHBhcnNlZC5ldmVudHMgPSB7XHJcblx0XHRcdHRhcDogdGFwIHx8IHNuYXAsXHJcblx0XHRcdGRyYWc6IGRyYWcsXHJcblx0XHRcdGZpeGVkOiBmaXhlZCxcclxuXHRcdFx0c25hcDogc25hcCxcclxuXHRcdFx0aG92ZXI6IGhvdmVyXHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdGVzdFRvb2x0aXBzICggcGFyc2VkLCBlbnRyeSApIHtcclxuXHJcblx0XHRpZiAoIGVudHJ5ID09PSBmYWxzZSApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGVsc2UgaWYgKCBlbnRyeSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdHBhcnNlZC50b29sdGlwcyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgcGFyc2VkLmhhbmRsZXM7IGkrKyApIHtcclxuXHRcdFx0XHRwYXJzZWQudG9vbHRpcHMucHVzaCh0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGVsc2Uge1xyXG5cclxuXHRcdFx0cGFyc2VkLnRvb2x0aXBzID0gYXNBcnJheShlbnRyeSk7XHJcblxyXG5cdFx0XHRpZiAoIHBhcnNlZC50b29sdGlwcy5sZW5ndGggIT09IHBhcnNlZC5oYW5kbGVzICkge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogbXVzdCBwYXNzIGEgZm9ybWF0dGVyIGZvciBhbGwgaGFuZGxlcy5cIik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHBhcnNlZC50b29sdGlwcy5mb3JFYWNoKGZ1bmN0aW9uKGZvcm1hdHRlcil7XHJcblx0XHRcdFx0aWYgKCB0eXBlb2YgZm9ybWF0dGVyICE9PSAnYm9vbGVhbicgJiYgKHR5cGVvZiBmb3JtYXR0ZXIgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBmb3JtYXR0ZXIudG8gIT09ICdmdW5jdGlvbicpICkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAndG9vbHRpcHMnIG11c3QgYmUgcGFzc2VkIGEgZm9ybWF0dGVyIG9yICdmYWxzZScuXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB0ZXN0Rm9ybWF0ICggcGFyc2VkLCBlbnRyeSApIHtcclxuXHJcblx0XHRwYXJzZWQuZm9ybWF0ID0gZW50cnk7XHJcblxyXG5cdFx0Ly8gQW55IG9iamVjdCB3aXRoIGEgdG8gYW5kIGZyb20gbWV0aG9kIGlzIHN1cHBvcnRlZC5cclxuXHRcdGlmICggdHlwZW9mIGVudHJ5LnRvID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlbnRyeS5mcm9tID09PSAnZnVuY3Rpb24nICkge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdmb3JtYXQnIHJlcXVpcmVzICd0bycgYW5kICdmcm9tJyBtZXRob2RzLlwiKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3RDc3NQcmVmaXggKCBwYXJzZWQsIGVudHJ5ICkge1xyXG5cclxuXHRcdGlmICggZW50cnkgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW50cnkgIT09ICdzdHJpbmcnICYmIGVudHJ5ICE9PSBmYWxzZSApIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnY3NzUHJlZml4JyBtdXN0IGJlIGEgc3RyaW5nIG9yIGBmYWxzZWAuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHBhcnNlZC5jc3NQcmVmaXggPSBlbnRyeTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3RDc3NDbGFzc2VzICggcGFyc2VkLCBlbnRyeSApIHtcclxuXHJcblx0XHRpZiAoIGVudHJ5ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVudHJ5ICE9PSAnb2JqZWN0JyApIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnY3NzQ2xhc3NlcycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdHlwZW9mIHBhcnNlZC5jc3NQcmVmaXggPT09ICdzdHJpbmcnICkge1xyXG5cdFx0XHRwYXJzZWQuY3NzQ2xhc3NlcyA9IHt9O1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBlbnRyeSApIHtcclxuXHRcdFx0XHRpZiAoICFlbnRyeS5oYXNPd25Qcm9wZXJ0eShrZXkpICkgeyBjb250aW51ZTsgfVxyXG5cclxuXHRcdFx0XHRwYXJzZWQuY3NzQ2xhc3Nlc1trZXldID0gcGFyc2VkLmNzc1ByZWZpeCArIGVudHJ5W2tleV07XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHBhcnNlZC5jc3NDbGFzc2VzID0gZW50cnk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB0ZXN0VXNlUmFmICggcGFyc2VkLCBlbnRyeSApIHtcclxuXHRcdGlmICggZW50cnkgPT09IHRydWUgfHwgZW50cnkgPT09IGZhbHNlICkge1xyXG5cdFx0XHRwYXJzZWQudXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZW50cnk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICd1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnIG9wdGlvbiBzaG91bGQgYmUgdHJ1ZSAoZGVmYXVsdCkgb3IgZmFsc2UuXCIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gVGVzdCBhbGwgZGV2ZWxvcGVyIHNldHRpbmdzIGFuZCBwYXJzZSB0byBhc3N1bXB0aW9uLXNhZmUgdmFsdWVzLlxyXG5cdGZ1bmN0aW9uIHRlc3RPcHRpb25zICggb3B0aW9ucyApIHtcclxuXHJcblx0XHQvLyBUbyBwcm92ZSBhIGZpeCBmb3IgIzUzNywgZnJlZXplIG9wdGlvbnMgaGVyZS5cclxuXHRcdC8vIElmIHRoZSBvYmplY3QgaXMgbW9kaWZpZWQsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxyXG5cdFx0Ly8gT2JqZWN0LmZyZWV6ZShvcHRpb25zKTtcclxuXHJcblx0XHR2YXIgcGFyc2VkID0ge1xyXG5cdFx0XHRtYXJnaW46IDAsXHJcblx0XHRcdGxpbWl0OiAwLFxyXG5cdFx0XHRwYWRkaW5nOiAwLFxyXG5cdFx0XHRhbmltYXRlOiB0cnVlLFxyXG5cdFx0XHRhbmltYXRpb25EdXJhdGlvbjogMzAwLFxyXG5cdFx0XHRmb3JtYXQ6IGRlZmF1bHRGb3JtYXR0ZXJcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gVGVzdHMgYXJlIGV4ZWN1dGVkIGluIHRoZSBvcmRlciB0aGV5IGFyZSBwcmVzZW50ZWQgaGVyZS5cclxuXHRcdHZhciB0ZXN0cyA9IHtcclxuXHRcdFx0J3N0ZXAnOiB7IHI6IGZhbHNlLCB0OiB0ZXN0U3RlcCB9LFxyXG5cdFx0XHQnc3RhcnQnOiB7IHI6IHRydWUsIHQ6IHRlc3RTdGFydCB9LFxyXG5cdFx0XHQnY29ubmVjdCc6IHsgcjogdHJ1ZSwgdDogdGVzdENvbm5lY3QgfSxcclxuXHRcdFx0J2RpcmVjdGlvbic6IHsgcjogdHJ1ZSwgdDogdGVzdERpcmVjdGlvbiB9LFxyXG5cdFx0XHQnc25hcCc6IHsgcjogZmFsc2UsIHQ6IHRlc3RTbmFwIH0sXHJcblx0XHRcdCdhbmltYXRlJzogeyByOiBmYWxzZSwgdDogdGVzdEFuaW1hdGUgfSxcclxuXHRcdFx0J2FuaW1hdGlvbkR1cmF0aW9uJzogeyByOiBmYWxzZSwgdDogdGVzdEFuaW1hdGlvbkR1cmF0aW9uIH0sXHJcblx0XHRcdCdyYW5nZSc6IHsgcjogdHJ1ZSwgdDogdGVzdFJhbmdlIH0sXHJcblx0XHRcdCdvcmllbnRhdGlvbic6IHsgcjogZmFsc2UsIHQ6IHRlc3RPcmllbnRhdGlvbiB9LFxyXG5cdFx0XHQnbWFyZ2luJzogeyByOiBmYWxzZSwgdDogdGVzdE1hcmdpbiB9LFxyXG5cdFx0XHQnbGltaXQnOiB7IHI6IGZhbHNlLCB0OiB0ZXN0TGltaXQgfSxcclxuXHRcdFx0J3BhZGRpbmcnOiB7IHI6IGZhbHNlLCB0OiB0ZXN0UGFkZGluZyB9LFxyXG5cdFx0XHQnYmVoYXZpb3VyJzogeyByOiB0cnVlLCB0OiB0ZXN0QmVoYXZpb3VyIH0sXHJcblx0XHRcdCdmb3JtYXQnOiB7IHI6IGZhbHNlLCB0OiB0ZXN0Rm9ybWF0IH0sXHJcblx0XHRcdCd0b29sdGlwcyc6IHsgcjogZmFsc2UsIHQ6IHRlc3RUb29sdGlwcyB9LFxyXG5cdFx0XHQnY3NzUHJlZml4JzogeyByOiBmYWxzZSwgdDogdGVzdENzc1ByZWZpeCB9LFxyXG5cdFx0XHQnY3NzQ2xhc3Nlcyc6IHsgcjogZmFsc2UsIHQ6IHRlc3RDc3NDbGFzc2VzIH0sXHJcblx0XHRcdCd1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnOiB7IHI6IGZhbHNlLCB0OiB0ZXN0VXNlUmFmIH1cclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIGRlZmF1bHRzID0ge1xyXG5cdFx0XHQnY29ubmVjdCc6IGZhbHNlLFxyXG5cdFx0XHQnZGlyZWN0aW9uJzogJ2x0cicsXHJcblx0XHRcdCdiZWhhdmlvdXInOiAndGFwJyxcclxuXHRcdFx0J29yaWVudGF0aW9uJzogJ2hvcml6b250YWwnLFxyXG5cdFx0XHQnY3NzUHJlZml4JyA6ICdub1VpLScsXHJcblx0XHRcdCdjc3NDbGFzc2VzJzoge1xyXG5cdFx0XHRcdHRhcmdldDogJ3RhcmdldCcsXHJcblx0XHRcdFx0YmFzZTogJ2Jhc2UnLFxyXG5cdFx0XHRcdG9yaWdpbjogJ29yaWdpbicsXHJcblx0XHRcdFx0aGFuZGxlOiAnaGFuZGxlJyxcclxuXHRcdFx0XHRoYW5kbGVMb3dlcjogJ2hhbmRsZS1sb3dlcicsXHJcblx0XHRcdFx0aGFuZGxlVXBwZXI6ICdoYW5kbGUtdXBwZXInLFxyXG5cdFx0XHRcdGhvcml6b250YWw6ICdob3Jpem9udGFsJyxcclxuXHRcdFx0XHR2ZXJ0aWNhbDogJ3ZlcnRpY2FsJyxcclxuXHRcdFx0XHRiYWNrZ3JvdW5kOiAnYmFja2dyb3VuZCcsXHJcblx0XHRcdFx0Y29ubmVjdDogJ2Nvbm5lY3QnLFxyXG5cdFx0XHRcdGx0cjogJ2x0cicsXHJcblx0XHRcdFx0cnRsOiAncnRsJyxcclxuXHRcdFx0XHRkcmFnZ2FibGU6ICdkcmFnZ2FibGUnLFxyXG5cdFx0XHRcdGRyYWc6ICdzdGF0ZS1kcmFnJyxcclxuXHRcdFx0XHR0YXA6ICdzdGF0ZS10YXAnLFxyXG5cdFx0XHRcdGFjdGl2ZTogJ2FjdGl2ZScsXHJcblx0XHRcdFx0dG9vbHRpcDogJ3Rvb2x0aXAnLFxyXG5cdFx0XHRcdHBpcHM6ICdwaXBzJyxcclxuXHRcdFx0XHRwaXBzSG9yaXpvbnRhbDogJ3BpcHMtaG9yaXpvbnRhbCcsXHJcblx0XHRcdFx0cGlwc1ZlcnRpY2FsOiAncGlwcy12ZXJ0aWNhbCcsXHJcblx0XHRcdFx0bWFya2VyOiAnbWFya2VyJyxcclxuXHRcdFx0XHRtYXJrZXJIb3Jpem9udGFsOiAnbWFya2VyLWhvcml6b250YWwnLFxyXG5cdFx0XHRcdG1hcmtlclZlcnRpY2FsOiAnbWFya2VyLXZlcnRpY2FsJyxcclxuXHRcdFx0XHRtYXJrZXJOb3JtYWw6ICdtYXJrZXItbm9ybWFsJyxcclxuXHRcdFx0XHRtYXJrZXJMYXJnZTogJ21hcmtlci1sYXJnZScsXHJcblx0XHRcdFx0bWFya2VyU3ViOiAnbWFya2VyLXN1YicsXHJcblx0XHRcdFx0dmFsdWU6ICd2YWx1ZScsXHJcblx0XHRcdFx0dmFsdWVIb3Jpem9udGFsOiAndmFsdWUtaG9yaXpvbnRhbCcsXHJcblx0XHRcdFx0dmFsdWVWZXJ0aWNhbDogJ3ZhbHVlLXZlcnRpY2FsJyxcclxuXHRcdFx0XHR2YWx1ZU5vcm1hbDogJ3ZhbHVlLW5vcm1hbCcsXHJcblx0XHRcdFx0dmFsdWVMYXJnZTogJ3ZhbHVlLWxhcmdlJyxcclxuXHRcdFx0XHR2YWx1ZVN1YjogJ3ZhbHVlLXN1YidcclxuXHRcdFx0fSxcclxuXHRcdFx0J3VzZVJlcXVlc3RBbmltYXRpb25GcmFtZSc6IHRydWVcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gUnVuIGFsbCBvcHRpb25zIHRocm91Z2ggYSB0ZXN0aW5nIG1lY2hhbmlzbSB0byBlbnN1cmUgY29ycmVjdFxyXG5cdFx0Ly8gaW5wdXQuIEl0IHNob3VsZCBiZSBub3RlZCB0aGF0IG9wdGlvbnMgbWlnaHQgZ2V0IG1vZGlmaWVkIHRvXHJcblx0XHQvLyBiZSBoYW5kbGVkIHByb3Blcmx5LiBFLmcuIHdyYXBwaW5nIGludGVnZXJzIGluIGFycmF5cy5cclxuXHRcdE9iamVjdC5rZXlzKHRlc3RzKS5mb3JFYWNoKGZ1bmN0aW9uKCBuYW1lICl7XHJcblxyXG5cdFx0XHQvLyBJZiB0aGUgb3B0aW9uIGlzbid0IHNldCwgYnV0IGl0IGlzIHJlcXVpcmVkLCB0aHJvdyBhbiBlcnJvci5cclxuXHRcdFx0aWYgKCBvcHRpb25zW25hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdHNbbmFtZV0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCB0ZXN0c1tuYW1lXS5yICkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnXCIgKyBuYW1lICsgXCInIGlzIHJlcXVpcmVkLlwiKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0ZXN0c1tuYW1lXS50KCBwYXJzZWQsIG9wdGlvbnNbbmFtZV0gPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRzW25hbWVdIDogb3B0aW9uc1tuYW1lXSApO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gRm9yd2FyZCBwaXBzIG9wdGlvbnNcclxuXHRcdHBhcnNlZC5waXBzID0gb3B0aW9ucy5waXBzO1xyXG5cclxuXHRcdHZhciBzdHlsZXMgPSBbWydsZWZ0JywgJ3RvcCddLCBbJ3JpZ2h0JywgJ2JvdHRvbSddXTtcclxuXHJcblx0XHQvLyBQcmUtZGVmaW5lIHRoZSBzdHlsZXMuXHJcblx0XHRwYXJzZWQuc3R5bGUgPSBzdHlsZXNbcGFyc2VkLmRpcl1bcGFyc2VkLm9ydF07XHJcblx0XHRwYXJzZWQuc3R5bGVPcG9zaXRlID0gc3R5bGVzW3BhcnNlZC5kaXI/MDoxXVtwYXJzZWQub3J0XTtcclxuXHJcblx0XHRyZXR1cm4gcGFyc2VkO1xyXG5cdH1cclxuXHJcblxyXG5mdW5jdGlvbiBjbG9zdXJlICggdGFyZ2V0LCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMgKXtcclxuXHJcblx0dmFyIGFjdGlvbnMgPSBnZXRBY3Rpb25zKCApO1xyXG5cclxuXHQvLyBBbGwgdmFyaWFibGVzIGxvY2FsIHRvICdjbG9zdXJlJyBhcmUgcHJlZml4ZWQgd2l0aCAnc2NvcGVfJ1xyXG5cdHZhciBzY29wZV9UYXJnZXQgPSB0YXJnZXQ7XHJcblx0dmFyIHNjb3BlX0xvY2F0aW9ucyA9IFtdO1xyXG5cdHZhciBzY29wZV9CYXNlO1xyXG5cdHZhciBzY29wZV9IYW5kbGVzO1xyXG5cdHZhciBzY29wZV9IYW5kbGVOdW1iZXJzID0gW107XHJcblx0dmFyIHNjb3BlX0FjdGl2ZUhhbmRsZSA9IGZhbHNlO1xyXG5cdHZhciBzY29wZV9Db25uZWN0cztcclxuXHR2YXIgc2NvcGVfU3BlY3RydW0gPSBvcHRpb25zLnNwZWN0cnVtO1xyXG5cdHZhciBzY29wZV9WYWx1ZXMgPSBbXTtcclxuXHR2YXIgc2NvcGVfRXZlbnRzID0ge307XHJcblx0dmFyIHNjb3BlX1NlbGY7XHJcblxyXG5cclxuXHQvLyBBcHBlbmQgYSBvcmlnaW4gdG8gdGhlIGJhc2VcclxuXHRmdW5jdGlvbiBhZGRPcmlnaW4gKCBiYXNlLCBoYW5kbGVOdW1iZXIgKSB7XHJcblxyXG5cdFx0dmFyIG9yaWdpbiA9IGFkZE5vZGVUbyhiYXNlLCBvcHRpb25zLmNzc0NsYXNzZXMub3JpZ2luKTtcclxuXHRcdHZhciBoYW5kbGUgPSBhZGROb2RlVG8ob3JpZ2luLCBvcHRpb25zLmNzc0NsYXNzZXMuaGFuZGxlKTtcclxuXHJcblx0XHRoYW5kbGUuc2V0QXR0cmlidXRlKCdkYXRhLWhhbmRsZScsIGhhbmRsZU51bWJlcik7XHJcblxyXG5cdFx0aWYgKCBoYW5kbGVOdW1iZXIgPT09IDAgKSB7XHJcblx0XHRcdGFkZENsYXNzKGhhbmRsZSwgb3B0aW9ucy5jc3NDbGFzc2VzLmhhbmRsZUxvd2VyKTtcclxuXHRcdH1cclxuXHJcblx0XHRlbHNlIGlmICggaGFuZGxlTnVtYmVyID09PSBvcHRpb25zLmhhbmRsZXMgLSAxICkge1xyXG5cdFx0XHRhZGRDbGFzcyhoYW5kbGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5oYW5kbGVVcHBlcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG9yaWdpbjtcclxuXHR9XHJcblxyXG5cdC8vIEluc2VydCBub2RlcyBmb3IgY29ubmVjdCBlbGVtZW50c1xyXG5cdGZ1bmN0aW9uIGFkZENvbm5lY3QgKCBiYXNlLCBhZGQgKSB7XHJcblxyXG5cdFx0aWYgKCAhYWRkICkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGFkZE5vZGVUbyhiYXNlLCBvcHRpb25zLmNzc0NsYXNzZXMuY29ubmVjdCk7XHJcblx0fVxyXG5cclxuXHQvLyBBZGQgaGFuZGxlcyB0byB0aGUgc2xpZGVyIGJhc2UuXHJcblx0ZnVuY3Rpb24gYWRkRWxlbWVudHMgKCBjb25uZWN0T3B0aW9ucywgYmFzZSApIHtcclxuXHJcblx0XHRzY29wZV9IYW5kbGVzID0gW107XHJcblx0XHRzY29wZV9Db25uZWN0cyA9IFtdO1xyXG5cclxuXHRcdHNjb3BlX0Nvbm5lY3RzLnB1c2goYWRkQ29ubmVjdChiYXNlLCBjb25uZWN0T3B0aW9uc1swXSkpO1xyXG5cclxuXHRcdC8vIFs6Ojo6Tz09PT1PPT09PU89PT09XVxyXG5cdFx0Ly8gY29ubmVjdE9wdGlvbnMgPSBbMCwgMSwgMSwgMV1cclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBvcHRpb25zLmhhbmRsZXM7IGkrKyApIHtcclxuXHRcdFx0Ly8gS2VlcCBhIGxpc3Qgb2YgYWxsIGFkZGVkIGhhbmRsZXMuXHJcblx0XHRcdHNjb3BlX0hhbmRsZXMucHVzaChhZGRPcmlnaW4oYmFzZSwgaSkpO1xyXG5cdFx0XHRzY29wZV9IYW5kbGVOdW1iZXJzW2ldID0gaTtcclxuXHRcdFx0c2NvcGVfQ29ubmVjdHMucHVzaChhZGRDb25uZWN0KGJhc2UsIGNvbm5lY3RPcHRpb25zW2kgKyAxXSkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gSW5pdGlhbGl6ZSBhIHNpbmdsZSBzbGlkZXIuXHJcblx0ZnVuY3Rpb24gYWRkU2xpZGVyICggdGFyZ2V0ICkge1xyXG5cclxuXHRcdC8vIEFwcGx5IGNsYXNzZXMgYW5kIGRhdGEgdG8gdGhlIHRhcmdldC5cclxuXHRcdGFkZENsYXNzKHRhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRhcmdldCk7XHJcblxyXG5cdFx0aWYgKCBvcHRpb25zLmRpciA9PT0gMCApIHtcclxuXHRcdFx0YWRkQ2xhc3ModGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMubHRyKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGFkZENsYXNzKHRhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnJ0bCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBvcHRpb25zLm9ydCA9PT0gMCApIHtcclxuXHRcdFx0YWRkQ2xhc3ModGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMuaG9yaXpvbnRhbCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRhZGRDbGFzcyh0YXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy52ZXJ0aWNhbCk7XHJcblx0XHR9XHJcblxyXG5cdFx0c2NvcGVfQmFzZSA9IGFkZE5vZGVUbyh0YXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5iYXNlKTtcclxuXHR9XHJcblxyXG5cclxuXHRmdW5jdGlvbiBhZGRUb29sdGlwICggaGFuZGxlLCBoYW5kbGVOdW1iZXIgKSB7XHJcblxyXG5cdFx0aWYgKCAhb3B0aW9ucy50b29sdGlwc1toYW5kbGVOdW1iZXJdICkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGFkZE5vZGVUbyhoYW5kbGUuZmlyc3RDaGlsZCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRvb2x0aXApO1xyXG5cdH1cclxuXHJcblx0Ly8gVGhlIHRvb2x0aXBzIG9wdGlvbiBpcyBhIHNob3J0aGFuZCBmb3IgdXNpbmcgdGhlICd1cGRhdGUnIGV2ZW50LlxyXG5cdGZ1bmN0aW9uIHRvb2x0aXBzICggKSB7XHJcblxyXG5cdFx0Ly8gVG9vbHRpcHMgYXJlIGFkZGVkIHdpdGggb3B0aW9ucy50b29sdGlwcyBpbiBvcmlnaW5hbCBvcmRlci5cclxuXHRcdHZhciB0aXBzID0gc2NvcGVfSGFuZGxlcy5tYXAoYWRkVG9vbHRpcCk7XHJcblxyXG5cdFx0YmluZEV2ZW50KCd1cGRhdGUnLCBmdW5jdGlvbih2YWx1ZXMsIGhhbmRsZU51bWJlciwgdW5lbmNvZGVkKSB7XHJcblxyXG5cdFx0XHRpZiAoICF0aXBzW2hhbmRsZU51bWJlcl0gKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgZm9ybWF0dGVkVmFsdWUgPSB2YWx1ZXNbaGFuZGxlTnVtYmVyXTtcclxuXHJcblx0XHRcdGlmICggb3B0aW9ucy50b29sdGlwc1toYW5kbGVOdW1iZXJdICE9PSB0cnVlICkge1xyXG5cdFx0XHRcdGZvcm1hdHRlZFZhbHVlID0gb3B0aW9ucy50b29sdGlwc1toYW5kbGVOdW1iZXJdLnRvKHVuZW5jb2RlZFtoYW5kbGVOdW1iZXJdKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGlwc1toYW5kbGVOdW1iZXJdLmlubmVySFRNTCA9IGZvcm1hdHRlZFZhbHVlO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHJcblx0ZnVuY3Rpb24gZ2V0R3JvdXAgKCBtb2RlLCB2YWx1ZXMsIHN0ZXBwZWQgKSB7XHJcblxyXG5cdFx0Ly8gVXNlIHRoZSByYW5nZS5cclxuXHRcdGlmICggbW9kZSA9PT0gJ3JhbmdlJyB8fCBtb2RlID09PSAnc3RlcHMnICkge1xyXG5cdFx0XHRyZXR1cm4gc2NvcGVfU3BlY3RydW0ueFZhbDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1vZGUgPT09ICdjb3VudCcgKSB7XHJcblxyXG5cdFx0XHRpZiAoICF2YWx1ZXMgKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAndmFsdWVzJyByZXF1aXJlZCBmb3IgbW9kZSAnY291bnQnLlwiKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gRGl2aWRlIDAgLSAxMDAgaW4gJ2NvdW50JyBwYXJ0cy5cclxuXHRcdFx0dmFyIHNwcmVhZCA9ICggMTAwIC8gKHZhbHVlcyAtIDEpICk7XHJcblx0XHRcdHZhciB2O1xyXG5cdFx0XHR2YXIgaSA9IDA7XHJcblxyXG5cdFx0XHR2YWx1ZXMgPSBbXTtcclxuXHJcblx0XHRcdC8vIExpc3QgdGhlc2UgcGFydHMgYW5kIGhhdmUgdGhlbSBoYW5kbGVkIGFzICdwb3NpdGlvbnMnLlxyXG5cdFx0XHR3aGlsZSAoICh2ID0gaSsrICogc3ByZWFkKSA8PSAxMDAgKSB7XHJcblx0XHRcdFx0dmFsdWVzLnB1c2godik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG1vZGUgPSAncG9zaXRpb25zJztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1vZGUgPT09ICdwb3NpdGlvbnMnICkge1xyXG5cclxuXHRcdFx0Ly8gTWFwIGFsbCBwZXJjZW50YWdlcyB0byBvbi1yYW5nZSB2YWx1ZXMuXHJcblx0XHRcdHJldHVybiB2YWx1ZXMubWFwKGZ1bmN0aW9uKCB2YWx1ZSApe1xyXG5cdFx0XHRcdHJldHVybiBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcoIHN0ZXBwZWQgPyBzY29wZV9TcGVjdHJ1bS5nZXRTdGVwKCB2YWx1ZSApIDogdmFsdWUgKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtb2RlID09PSAndmFsdWVzJyApIHtcclxuXHJcblx0XHRcdC8vIElmIHRoZSB2YWx1ZSBtdXN0IGJlIHN0ZXBwZWQsIGl0IG5lZWRzIHRvIGJlIGNvbnZlcnRlZCB0byBhIHBlcmNlbnRhZ2UgZmlyc3QuXHJcblx0XHRcdGlmICggc3RlcHBlZCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHZhbHVlcy5tYXAoZnVuY3Rpb24oIHZhbHVlICl7XHJcblxyXG5cdFx0XHRcdFx0Ly8gQ29udmVydCB0byBwZXJjZW50YWdlLCBhcHBseSBzdGVwLCByZXR1cm4gdG8gdmFsdWUuXHJcblx0XHRcdFx0XHRyZXR1cm4gc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKCBzY29wZV9TcGVjdHJ1bS5nZXRTdGVwKCBzY29wZV9TcGVjdHJ1bS50b1N0ZXBwaW5nKCB2YWx1ZSApICkgKTtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIE90aGVyd2lzZSwgd2UgY2FuIHNpbXBseSB1c2UgdGhlIHZhbHVlcy5cclxuXHRcdFx0cmV0dXJuIHZhbHVlcztcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdlbmVyYXRlU3ByZWFkICggZGVuc2l0eSwgbW9kZSwgZ3JvdXAgKSB7XHJcblxyXG5cdFx0ZnVuY3Rpb24gc2FmZUluY3JlbWVudCh2YWx1ZSwgaW5jcmVtZW50KSB7XHJcblx0XHRcdC8vIEF2b2lkIGZsb2F0aW5nIHBvaW50IHZhcmlhbmNlIGJ5IGRyb3BwaW5nIHRoZSBzbWFsbGVzdCBkZWNpbWFsIHBsYWNlcy5cclxuXHRcdFx0cmV0dXJuICh2YWx1ZSArIGluY3JlbWVudCkudG9GaXhlZCg3KSAvIDE7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGluZGV4ZXMgPSB7fTtcclxuXHRcdHZhciBmaXJzdEluUmFuZ2UgPSBzY29wZV9TcGVjdHJ1bS54VmFsWzBdO1xyXG5cdFx0dmFyIGxhc3RJblJhbmdlID0gc2NvcGVfU3BlY3RydW0ueFZhbFtzY29wZV9TcGVjdHJ1bS54VmFsLmxlbmd0aC0xXTtcclxuXHRcdHZhciBpZ25vcmVGaXJzdCA9IGZhbHNlO1xyXG5cdFx0dmFyIGlnbm9yZUxhc3QgPSBmYWxzZTtcclxuXHRcdHZhciBwcmV2UGN0ID0gMDtcclxuXHJcblx0XHQvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBncm91cCwgc29ydCBpdCBhbmQgZmlsdGVyIGF3YXkgYWxsIGR1cGxpY2F0ZXMuXHJcblx0XHRncm91cCA9IHVuaXF1ZShncm91cC5zbGljZSgpLnNvcnQoZnVuY3Rpb24oYSwgYil7IHJldHVybiBhIC0gYjsgfSkpO1xyXG5cclxuXHRcdC8vIE1ha2Ugc3VyZSB0aGUgcmFuZ2Ugc3RhcnRzIHdpdGggdGhlIGZpcnN0IGVsZW1lbnQuXHJcblx0XHRpZiAoIGdyb3VwWzBdICE9PSBmaXJzdEluUmFuZ2UgKSB7XHJcblx0XHRcdGdyb3VwLnVuc2hpZnQoZmlyc3RJblJhbmdlKTtcclxuXHRcdFx0aWdub3JlRmlyc3QgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIExpa2V3aXNlIGZvciB0aGUgbGFzdCBvbmUuXHJcblx0XHRpZiAoIGdyb3VwW2dyb3VwLmxlbmd0aCAtIDFdICE9PSBsYXN0SW5SYW5nZSApIHtcclxuXHRcdFx0Z3JvdXAucHVzaChsYXN0SW5SYW5nZSk7XHJcblx0XHRcdGlnbm9yZUxhc3QgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGdyb3VwLmZvckVhY2goZnVuY3Rpb24gKCBjdXJyZW50LCBpbmRleCApIHtcclxuXHJcblx0XHRcdC8vIEdldCB0aGUgY3VycmVudCBzdGVwIGFuZCB0aGUgbG93ZXIgKyB1cHBlciBwb3NpdGlvbnMuXHJcblx0XHRcdHZhciBzdGVwO1xyXG5cdFx0XHR2YXIgaTtcclxuXHRcdFx0dmFyIHE7XHJcblx0XHRcdHZhciBsb3cgPSBjdXJyZW50O1xyXG5cdFx0XHR2YXIgaGlnaCA9IGdyb3VwW2luZGV4KzFdO1xyXG5cdFx0XHR2YXIgbmV3UGN0O1xyXG5cdFx0XHR2YXIgcGN0RGlmZmVyZW5jZTtcclxuXHRcdFx0dmFyIHBjdFBvcztcclxuXHRcdFx0dmFyIHR5cGU7XHJcblx0XHRcdHZhciBzdGVwcztcclxuXHRcdFx0dmFyIHJlYWxTdGVwcztcclxuXHRcdFx0dmFyIHN0ZXBzaXplO1xyXG5cclxuXHRcdFx0Ly8gV2hlbiB1c2luZyAnc3RlcHMnIG1vZGUsIHVzZSB0aGUgcHJvdmlkZWQgc3RlcHMuXHJcblx0XHRcdC8vIE90aGVyd2lzZSwgd2UnbGwgc3RlcCBvbiB0byB0aGUgbmV4dCBzdWJyYW5nZS5cclxuXHRcdFx0aWYgKCBtb2RlID09PSAnc3RlcHMnICkge1xyXG5cdFx0XHRcdHN0ZXAgPSBzY29wZV9TcGVjdHJ1bS54TnVtU3RlcHNbIGluZGV4IF07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIERlZmF1bHQgdG8gYSAnZnVsbCcgc3RlcC5cclxuXHRcdFx0aWYgKCAhc3RlcCApIHtcclxuXHRcdFx0XHRzdGVwID0gaGlnaC1sb3c7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIExvdyBjYW4gYmUgMCwgc28gdGVzdCBmb3IgZmFsc2UuIElmIGhpZ2ggaXMgdW5kZWZpbmVkLFxyXG5cdFx0XHQvLyB3ZSBhcmUgYXQgdGhlIGxhc3Qgc3VicmFuZ2UuIEluZGV4IDAgaXMgYWxyZWFkeSBoYW5kbGVkLlxyXG5cdFx0XHRpZiAoIGxvdyA9PT0gZmFsc2UgfHwgaGlnaCA9PT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gTWFrZSBzdXJlIHN0ZXAgaXNuJ3QgMCwgd2hpY2ggd291bGQgY2F1c2UgYW4gaW5maW5pdGUgbG9vcCAoIzY1NClcclxuXHRcdFx0c3RlcCA9IE1hdGgubWF4KHN0ZXAsIDAuMDAwMDAwMSk7XHJcblxyXG5cdFx0XHQvLyBGaW5kIGFsbCBzdGVwcyBpbiB0aGUgc3VicmFuZ2UuXHJcblx0XHRcdGZvciAoIGkgPSBsb3c7IGkgPD0gaGlnaDsgaSA9IHNhZmVJbmNyZW1lbnQoaSwgc3RlcCkgKSB7XHJcblxyXG5cdFx0XHRcdC8vIEdldCB0aGUgcGVyY2VudGFnZSB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQgc3RlcCxcclxuXHRcdFx0XHQvLyBjYWxjdWxhdGUgdGhlIHNpemUgZm9yIHRoZSBzdWJyYW5nZS5cclxuXHRcdFx0XHRuZXdQY3QgPSBzY29wZV9TcGVjdHJ1bS50b1N0ZXBwaW5nKCBpICk7XHJcblx0XHRcdFx0cGN0RGlmZmVyZW5jZSA9IG5ld1BjdCAtIHByZXZQY3Q7XHJcblxyXG5cdFx0XHRcdHN0ZXBzID0gcGN0RGlmZmVyZW5jZSAvIGRlbnNpdHk7XHJcblx0XHRcdFx0cmVhbFN0ZXBzID0gTWF0aC5yb3VuZChzdGVwcyk7XHJcblxyXG5cdFx0XHRcdC8vIFRoaXMgcmF0aW8gcmVwcmVzZW50cyB0aGUgYW1tb3VudCBvZiBwZXJjZW50YWdlLXNwYWNlIGEgcG9pbnQgaW5kaWNhdGVzLlxyXG5cdFx0XHRcdC8vIEZvciBhIGRlbnNpdHkgMSB0aGUgcG9pbnRzL3BlcmNlbnRhZ2UgPSAxLiBGb3IgZGVuc2l0eSAyLCB0aGF0IHBlcmNlbnRhZ2UgbmVlZHMgdG8gYmUgcmUtZGV2aWRlZC5cclxuXHRcdFx0XHQvLyBSb3VuZCB0aGUgcGVyY2VudGFnZSBvZmZzZXQgdG8gYW4gZXZlbiBudW1iZXIsIHRoZW4gZGl2aWRlIGJ5IHR3b1xyXG5cdFx0XHRcdC8vIHRvIHNwcmVhZCB0aGUgb2Zmc2V0IG9uIGJvdGggc2lkZXMgb2YgdGhlIHJhbmdlLlxyXG5cdFx0XHRcdHN0ZXBzaXplID0gcGN0RGlmZmVyZW5jZS9yZWFsU3RlcHM7XHJcblxyXG5cdFx0XHRcdC8vIERpdmlkZSBhbGwgcG9pbnRzIGV2ZW5seSwgYWRkaW5nIHRoZSBjb3JyZWN0IG51bWJlciB0byB0aGlzIHN1YnJhbmdlLlxyXG5cdFx0XHRcdC8vIFJ1biB1cCB0byA8PSBzbyB0aGF0IDEwMCUgZ2V0cyBhIHBvaW50LCBldmVudCBpZiBpZ25vcmVMYXN0IGlzIHNldC5cclxuXHRcdFx0XHRmb3IgKCBxID0gMTsgcSA8PSByZWFsU3RlcHM7IHEgKz0gMSApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBUaGUgcmF0aW8gYmV0d2VlbiB0aGUgcm91bmRlZCB2YWx1ZSBhbmQgdGhlIGFjdHVhbCBzaXplIG1pZ2h0IGJlIH4xJSBvZmYuXHJcblx0XHRcdFx0XHQvLyBDb3JyZWN0IHRoZSBwZXJjZW50YWdlIG9mZnNldCBieSB0aGUgbnVtYmVyIG9mIHBvaW50c1xyXG5cdFx0XHRcdFx0Ly8gcGVyIHN1YnJhbmdlLiBkZW5zaXR5ID0gMSB3aWxsIHJlc3VsdCBpbiAxMDAgcG9pbnRzIG9uIHRoZVxyXG5cdFx0XHRcdFx0Ly8gZnVsbCByYW5nZSwgMiBmb3IgNTAsIDQgZm9yIDI1LCBldGMuXHJcblx0XHRcdFx0XHRwY3RQb3MgPSBwcmV2UGN0ICsgKCBxICogc3RlcHNpemUgKTtcclxuXHRcdFx0XHRcdGluZGV4ZXNbcGN0UG9zLnRvRml4ZWQoNSldID0gWyd4JywgMF07XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBEZXRlcm1pbmUgdGhlIHBvaW50IHR5cGUuXHJcblx0XHRcdFx0dHlwZSA9IChncm91cC5pbmRleE9mKGkpID4gLTEpID8gMSA6ICggbW9kZSA9PT0gJ3N0ZXBzJyA/IDIgOiAwICk7XHJcblxyXG5cdFx0XHRcdC8vIEVuZm9yY2UgdGhlICdpZ25vcmVGaXJzdCcgb3B0aW9uIGJ5IG92ZXJ3cml0aW5nIHRoZSB0eXBlIGZvciAwLlxyXG5cdFx0XHRcdGlmICggIWluZGV4ICYmIGlnbm9yZUZpcnN0ICkge1xyXG5cdFx0XHRcdFx0dHlwZSA9IDA7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoICEoaSA9PT0gaGlnaCAmJiBpZ25vcmVMYXN0KSkge1xyXG5cdFx0XHRcdFx0Ly8gTWFyayB0aGUgJ3R5cGUnIG9mIHRoaXMgcG9pbnQuIDAgPSBwbGFpbiwgMSA9IHJlYWwgdmFsdWUsIDIgPSBzdGVwIHZhbHVlLlxyXG5cdFx0XHRcdFx0aW5kZXhlc1tuZXdQY3QudG9GaXhlZCg1KV0gPSBbaSwgdHlwZV07XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBVcGRhdGUgdGhlIHBlcmNlbnRhZ2UgY291bnQuXHJcblx0XHRcdFx0cHJldlBjdCA9IG5ld1BjdDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIGluZGV4ZXM7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBhZGRNYXJraW5nICggc3ByZWFkLCBmaWx0ZXJGdW5jLCBmb3JtYXR0ZXIgKSB7XHJcblxyXG5cdFx0dmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdHZhciBvdXQgPSAnJztcclxuXHRcdHZhciB2YWx1ZVNpemVDbGFzc2VzID0gW1xyXG5cdFx0XHRvcHRpb25zLmNzc0NsYXNzZXMudmFsdWVOb3JtYWwsXHJcblx0XHRcdG9wdGlvbnMuY3NzQ2xhc3Nlcy52YWx1ZUxhcmdlLFxyXG5cdFx0XHRvcHRpb25zLmNzc0NsYXNzZXMudmFsdWVTdWJcclxuXHRcdF07XHJcblx0XHR2YXIgbWFya2VyU2l6ZUNsYXNzZXMgPSBbXHJcblx0XHRcdG9wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXJOb3JtYWwsXHJcblx0XHRcdG9wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXJMYXJnZSxcclxuXHRcdFx0b3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlclN1YlxyXG5cdFx0XTtcclxuXHRcdHZhciB2YWx1ZU9yaWVudGF0aW9uQ2xhc3NlcyA9IFtcclxuXHRcdFx0b3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlSG9yaXpvbnRhbCxcclxuXHRcdFx0b3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlVmVydGljYWxcclxuXHRcdF07XHJcblx0XHR2YXIgbWFya2VyT3JpZW50YXRpb25DbGFzc2VzID0gW1xyXG5cdFx0XHRvcHRpb25zLmNzc0NsYXNzZXMubWFya2VySG9yaXpvbnRhbCxcclxuXHRcdFx0b3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlclZlcnRpY2FsXHJcblx0XHRdO1xyXG5cclxuXHRcdGFkZENsYXNzKGVsZW1lbnQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5waXBzKTtcclxuXHRcdGFkZENsYXNzKGVsZW1lbnQsIG9wdGlvbnMub3J0ID09PSAwID8gb3B0aW9ucy5jc3NDbGFzc2VzLnBpcHNIb3Jpem9udGFsIDogb3B0aW9ucy5jc3NDbGFzc2VzLnBpcHNWZXJ0aWNhbCk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0Q2xhc3NlcyggdHlwZSwgc291cmNlICl7XHJcblx0XHRcdHZhciBhID0gc291cmNlID09PSBvcHRpb25zLmNzc0NsYXNzZXMudmFsdWU7XHJcblx0XHRcdHZhciBvcmllbnRhdGlvbkNsYXNzZXMgPSBhID8gdmFsdWVPcmllbnRhdGlvbkNsYXNzZXMgOiBtYXJrZXJPcmllbnRhdGlvbkNsYXNzZXM7XHJcblx0XHRcdHZhciBzaXplQ2xhc3NlcyA9IGEgPyB2YWx1ZVNpemVDbGFzc2VzIDogbWFya2VyU2l6ZUNsYXNzZXM7XHJcblxyXG5cdFx0XHRyZXR1cm4gc291cmNlICsgJyAnICsgb3JpZW50YXRpb25DbGFzc2VzW29wdGlvbnMub3J0XSArICcgJyArIHNpemVDbGFzc2VzW3R5cGVdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGdldFRhZ3MoIG9mZnNldCwgc291cmNlLCB2YWx1ZXMgKSB7XHJcblx0XHRcdHJldHVybiAnY2xhc3M9XCInICsgZ2V0Q2xhc3Nlcyh2YWx1ZXNbMV0sIHNvdXJjZSkgKyAnXCIgc3R5bGU9XCInICsgb3B0aW9ucy5zdHlsZSArICc6ICcgKyBvZmZzZXQgKyAnJVwiJztcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBhZGRTcHJlYWQgKCBvZmZzZXQsIHZhbHVlcyApe1xyXG5cclxuXHRcdFx0Ly8gQXBwbHkgdGhlIGZpbHRlciBmdW5jdGlvbiwgaWYgaXQgaXMgc2V0LlxyXG5cdFx0XHR2YWx1ZXNbMV0gPSAodmFsdWVzWzFdICYmIGZpbHRlckZ1bmMpID8gZmlsdGVyRnVuYyh2YWx1ZXNbMF0sIHZhbHVlc1sxXSkgOiB2YWx1ZXNbMV07XHJcblxyXG5cdFx0XHQvLyBBZGQgYSBtYXJrZXIgZm9yIGV2ZXJ5IHBvaW50XHJcblx0XHRcdG91dCArPSAnPGRpdiAnICsgZ2V0VGFncyhvZmZzZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXIsIHZhbHVlcykgKyAnPjwvZGl2Pic7XHJcblxyXG5cdFx0XHQvLyBWYWx1ZXMgYXJlIG9ubHkgYXBwZW5kZWQgZm9yIHBvaW50cyBtYXJrZWQgJzEnIG9yICcyJy5cclxuXHRcdFx0aWYgKCB2YWx1ZXNbMV0gKSB7XHJcblx0XHRcdFx0b3V0ICs9ICc8ZGl2ICcgKyBnZXRUYWdzKG9mZnNldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlLCB2YWx1ZXMpICsgJz4nICsgZm9ybWF0dGVyLnRvKHZhbHVlc1swXSkgKyAnPC9kaXY+JztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFwcGVuZCBhbGwgcG9pbnRzLlxyXG5cdFx0T2JqZWN0LmtleXMoc3ByZWFkKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe1xyXG5cdFx0XHRhZGRTcHJlYWQoYSwgc3ByZWFkW2FdKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdGVsZW1lbnQuaW5uZXJIVE1MID0gb3V0O1xyXG5cclxuXHRcdHJldHVybiBlbGVtZW50O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcGlwcyAoIGdyaWQgKSB7XHJcblxyXG5cdFx0dmFyIG1vZGUgPSBncmlkLm1vZGU7XHJcblx0XHR2YXIgZGVuc2l0eSA9IGdyaWQuZGVuc2l0eSB8fCAxO1xyXG5cdFx0dmFyIGZpbHRlciA9IGdyaWQuZmlsdGVyIHx8IGZhbHNlO1xyXG5cdFx0dmFyIHZhbHVlcyA9IGdyaWQudmFsdWVzIHx8IGZhbHNlO1xyXG5cdFx0dmFyIHN0ZXBwZWQgPSBncmlkLnN0ZXBwZWQgfHwgZmFsc2U7XHJcblx0XHR2YXIgZ3JvdXAgPSBnZXRHcm91cCggbW9kZSwgdmFsdWVzLCBzdGVwcGVkICk7XHJcblx0XHR2YXIgc3ByZWFkID0gZ2VuZXJhdGVTcHJlYWQoIGRlbnNpdHksIG1vZGUsIGdyb3VwICk7XHJcblx0XHR2YXIgZm9ybWF0ID0gZ3JpZC5mb3JtYXQgfHwge1xyXG5cdFx0XHR0bzogTWF0aC5yb3VuZFxyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gc2NvcGVfVGFyZ2V0LmFwcGVuZENoaWxkKGFkZE1hcmtpbmcoXHJcblx0XHRcdHNwcmVhZCxcclxuXHRcdFx0ZmlsdGVyLFxyXG5cdFx0XHRmb3JtYXRcclxuXHRcdCkpO1xyXG5cdH1cclxuXHJcblxyXG5cdC8vIFNob3J0aGFuZCBmb3IgYmFzZSBkaW1lbnNpb25zLlxyXG5cdGZ1bmN0aW9uIGJhc2VTaXplICggKSB7XHJcblx0XHR2YXIgcmVjdCA9IHNjb3BlX0Jhc2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGFsdCA9ICdvZmZzZXQnICsgWydXaWR0aCcsICdIZWlnaHQnXVtvcHRpb25zLm9ydF07XHJcblx0XHRyZXR1cm4gb3B0aW9ucy5vcnQgPT09IDAgPyAocmVjdC53aWR0aHx8c2NvcGVfQmFzZVthbHRdKSA6IChyZWN0LmhlaWdodHx8c2NvcGVfQmFzZVthbHRdKTtcclxuXHR9XHJcblxyXG5cdC8vIEhhbmRsZXIgZm9yIGF0dGFjaGluZyBldmVudHMgdHJvdWdoIGEgcHJveHkuXHJcblx0ZnVuY3Rpb24gYXR0YWNoRXZlbnQgKCBldmVudHMsIGVsZW1lbnQsIGNhbGxiYWNrLCBkYXRhICkge1xyXG5cclxuXHRcdC8vIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gJ2ZpbHRlcicgZXZlbnRzIHRvIHRoZSBzbGlkZXIuXHJcblx0XHQvLyBlbGVtZW50IGlzIGEgbm9kZSwgbm90IGEgbm9kZUxpc3RcclxuXHJcblx0XHR2YXIgbWV0aG9kID0gZnVuY3Rpb24gKCBlICl7XHJcblxyXG5cdFx0XHRpZiAoIHNjb3BlX1RhcmdldC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBTdG9wIGlmIGFuIGFjdGl2ZSAndGFwJyB0cmFuc2l0aW9uIGlzIHRha2luZyBwbGFjZS5cclxuXHRcdFx0aWYgKCBoYXNDbGFzcyhzY29wZV9UYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50YXApICkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZSA9IGZpeEV2ZW50KGUsIGRhdGEucGFnZU9mZnNldCk7XHJcblxyXG5cdFx0XHQvLyBIYW5kbGUgcmVqZWN0IG9mIG11bHRpdG91Y2hcclxuXHRcdFx0aWYgKCAhZSApIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIElnbm9yZSByaWdodCBvciBtaWRkbGUgY2xpY2tzIG9uIHN0YXJ0ICM0NTRcclxuXHRcdFx0aWYgKCBldmVudHMgPT09IGFjdGlvbnMuc3RhcnQgJiYgZS5idXR0b25zICE9PSB1bmRlZmluZWQgJiYgZS5idXR0b25zID4gMSApIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIElnbm9yZSByaWdodCBvciBtaWRkbGUgY2xpY2tzIG9uIHN0YXJ0ICM0NTRcclxuXHRcdFx0aWYgKCBkYXRhLmhvdmVyICYmIGUuYnV0dG9ucyApIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGUuY2FsY1BvaW50ID0gZS5wb2ludHNbIG9wdGlvbnMub3J0IF07XHJcblxyXG5cdFx0XHQvLyBDYWxsIHRoZSBldmVudCBoYW5kbGVyIHdpdGggdGhlIGV2ZW50IFsgYW5kIGFkZGl0aW9uYWwgZGF0YSBdLlxyXG5cdFx0XHRjYWxsYmFjayAoIGUsIGRhdGEgKTtcclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIG1ldGhvZHMgPSBbXTtcclxuXHJcblx0XHQvLyBCaW5kIGEgY2xvc3VyZSBvbiB0aGUgdGFyZ2V0IGZvciBldmVyeSBldmVudCB0eXBlLlxyXG5cdFx0ZXZlbnRzLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiggZXZlbnROYW1lICl7XHJcblx0XHRcdGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIG1ldGhvZCwgZmFsc2UpO1xyXG5cdFx0XHRtZXRob2RzLnB1c2goW2V2ZW50TmFtZSwgbWV0aG9kXSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gbWV0aG9kcztcclxuXHR9XHJcblxyXG5cdC8vIFByb3ZpZGUgYSBjbGVhbiBldmVudCB3aXRoIHN0YW5kYXJkaXplZCBvZmZzZXQgdmFsdWVzLlxyXG5cdGZ1bmN0aW9uIGZpeEV2ZW50ICggZSwgcGFnZU9mZnNldCApIHtcclxuXHJcblx0XHQvLyBQcmV2ZW50IHNjcm9sbGluZyBhbmQgcGFubmluZyBvbiB0b3VjaCBldmVudHMsIHdoaWxlXHJcblx0XHQvLyBhdHRlbXB0aW5nIHRvIHNsaWRlLiBUaGUgdGFwIGV2ZW50IGFsc28gZGVwZW5kcyBvbiB0aGlzLlxyXG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuXHRcdC8vIEZpbHRlciB0aGUgZXZlbnQgdG8gcmVnaXN0ZXIgdGhlIHR5cGUsIHdoaWNoIGNhbiBiZVxyXG5cdFx0Ly8gdG91Y2gsIG1vdXNlIG9yIHBvaW50ZXIuIE9mZnNldCBjaGFuZ2VzIG5lZWQgdG8gYmVcclxuXHRcdC8vIG1hZGUgb24gYW4gZXZlbnQgc3BlY2lmaWMgYmFzaXMuXHJcblx0XHR2YXIgdG91Y2ggPSBlLnR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gMDtcclxuXHRcdHZhciBtb3VzZSA9IGUudHlwZS5pbmRleE9mKCdtb3VzZScpID09PSAwO1xyXG5cdFx0dmFyIHBvaW50ZXIgPSBlLnR5cGUuaW5kZXhPZigncG9pbnRlcicpID09PSAwO1xyXG5cdFx0dmFyIHg7XHJcblx0XHR2YXIgeTtcclxuXHJcblx0XHQvLyBJRTEwIGltcGxlbWVudGVkIHBvaW50ZXIgZXZlbnRzIHdpdGggYSBwcmVmaXg7XHJcblx0XHRpZiAoIGUudHlwZS5pbmRleE9mKCdNU1BvaW50ZXInKSA9PT0gMCApIHtcclxuXHRcdFx0cG9pbnRlciA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0b3VjaCApIHtcclxuXHJcblx0XHRcdC8vIEZpeCBidWcgd2hlbiB1c2VyIHRvdWNoZXMgd2l0aCB0d28gb3IgbW9yZSBmaW5nZXJzIG9uIG1vYmlsZSBkZXZpY2VzLlxyXG5cdFx0XHQvLyBJdCdzIHVzZWZ1bCB3aGVuIHlvdSBoYXZlIHR3byBvciBtb3JlIHNsaWRlcnMgb24gb25lIHBhZ2UsXHJcblx0XHRcdC8vIHRoYXQgY2FuIGJlIHRvdWNoZWQgc2ltdWx0YW5lb3VzbHkuXHJcblx0XHRcdC8vICM2NDksICM2NjMsICM2NjhcclxuXHRcdFx0aWYgKCBlLnRvdWNoZXMubGVuZ3RoID4gMSApIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIG5vVWlTbGlkZXIgc3VwcG9ydHMgb25lIG1vdmVtZW50IGF0IGEgdGltZSxcclxuXHRcdFx0Ly8gc28gd2UgY2FuIHNlbGVjdCB0aGUgZmlyc3QgJ2NoYW5nZWRUb3VjaCcuXHJcblx0XHRcdHggPSBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xyXG5cdFx0XHR5ID0gZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWTtcclxuXHRcdH1cclxuXHJcblx0XHRwYWdlT2Zmc2V0ID0gcGFnZU9mZnNldCB8fCBnZXRQYWdlT2Zmc2V0KCk7XHJcblxyXG5cdFx0aWYgKCBtb3VzZSB8fCBwb2ludGVyICkge1xyXG5cdFx0XHR4ID0gZS5jbGllbnRYICsgcGFnZU9mZnNldC54O1xyXG5cdFx0XHR5ID0gZS5jbGllbnRZICsgcGFnZU9mZnNldC55O1xyXG5cdFx0fVxyXG5cclxuXHRcdGUucGFnZU9mZnNldCA9IHBhZ2VPZmZzZXQ7XHJcblx0XHRlLnBvaW50cyA9IFt4LCB5XTtcclxuXHRcdGUuY3Vyc29yID0gbW91c2UgfHwgcG9pbnRlcjsgLy8gRml4ICM0MzVcclxuXHJcblx0XHRyZXR1cm4gZTtcclxuXHR9XHJcblxyXG5cdC8vIFRyYW5zbGF0ZSBhIGNvb3JkaW5hdGUgaW4gdGhlIGRvY3VtZW50IHRvIGEgcGVyY2VudGFnZSBvbiB0aGUgc2xpZGVyXHJcblx0ZnVuY3Rpb24gY2FsY1BvaW50VG9QZXJjZW50YWdlICggY2FsY1BvaW50ICkge1xyXG5cdFx0dmFyIGxvY2F0aW9uID0gY2FsY1BvaW50IC0gb2Zmc2V0KHNjb3BlX0Jhc2UsIG9wdGlvbnMub3J0KTtcclxuXHRcdHZhciBwcm9wb3NhbCA9ICggbG9jYXRpb24gKiAxMDAgKSAvIGJhc2VTaXplKCk7XHJcblx0XHRyZXR1cm4gb3B0aW9ucy5kaXIgPyAxMDAgLSBwcm9wb3NhbCA6IHByb3Bvc2FsO1xyXG5cdH1cclxuXHJcblx0Ly8gRmluZCBoYW5kbGUgY2xvc2VzdCB0byBhIGNlcnRhaW4gcGVyY2VudGFnZSBvbiB0aGUgc2xpZGVyXHJcblx0ZnVuY3Rpb24gZ2V0Q2xvc2VzdEhhbmRsZSAoIHByb3Bvc2FsICkge1xyXG5cclxuXHRcdHZhciBjbG9zZXN0ID0gMTAwO1xyXG5cdFx0dmFyIGhhbmRsZU51bWJlciA9IGZhbHNlO1xyXG5cclxuXHRcdHNjb3BlX0hhbmRsZXMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGUsIGluZGV4KXtcclxuXHJcblx0XHRcdC8vIERpc2FibGVkIGhhbmRsZXMgYXJlIGlnbm9yZWRcclxuXHRcdFx0aWYgKCBoYW5kbGUuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpICkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHBvcyA9IE1hdGguYWJzKHNjb3BlX0xvY2F0aW9uc1tpbmRleF0gLSBwcm9wb3NhbCk7XHJcblxyXG5cdFx0XHRpZiAoIHBvcyA8IGNsb3Nlc3QgKSB7XHJcblx0XHRcdFx0aGFuZGxlTnVtYmVyID0gaW5kZXg7XHJcblx0XHRcdFx0Y2xvc2VzdCA9IHBvcztcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIGhhbmRsZU51bWJlcjtcclxuXHR9XHJcblxyXG5cdC8vIE1vdmVzIGhhbmRsZShzKSBieSBhIHBlcmNlbnRhZ2VcclxuXHQvLyAoYm9vbCwgJSB0byBtb3ZlLCBbJSB3aGVyZSBoYW5kbGUgc3RhcnRlZCwgLi4uXSwgW2luZGV4IGluIHNjb3BlX0hhbmRsZXMsIC4uLl0pXHJcblx0ZnVuY3Rpb24gbW92ZUhhbmRsZXMgKCB1cHdhcmQsIHByb3Bvc2FsLCBsb2NhdGlvbnMsIGhhbmRsZU51bWJlcnMgKSB7XHJcblxyXG5cdFx0dmFyIHByb3Bvc2FscyA9IGxvY2F0aW9ucy5zbGljZSgpO1xyXG5cclxuXHRcdHZhciBiID0gWyF1cHdhcmQsIHVwd2FyZF07XHJcblx0XHR2YXIgZiA9IFt1cHdhcmQsICF1cHdhcmRdO1xyXG5cclxuXHRcdC8vIENvcHkgaGFuZGxlTnVtYmVycyBzbyB3ZSBkb24ndCBjaGFuZ2UgdGhlIGRhdGFzZXRcclxuXHRcdGhhbmRsZU51bWJlcnMgPSBoYW5kbGVOdW1iZXJzLnNsaWNlKCk7XHJcblxyXG5cdFx0Ly8gQ2hlY2sgdG8gc2VlIHdoaWNoIGhhbmRsZSBpcyAnbGVhZGluZycuXHJcblx0XHQvLyBJZiB0aGF0IG9uZSBjYW4ndCBtb3ZlIHRoZSBzZWNvbmQgY2FuJ3QgZWl0aGVyLlxyXG5cdFx0aWYgKCB1cHdhcmQgKSB7XHJcblx0XHRcdGhhbmRsZU51bWJlcnMucmV2ZXJzZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFN0ZXAgMTogZ2V0IHRoZSBtYXhpbXVtIHBlcmNlbnRhZ2UgdGhhdCBhbnkgb2YgdGhlIGhhbmRsZXMgY2FuIG1vdmVcclxuXHRcdGlmICggaGFuZGxlTnVtYmVycy5sZW5ndGggPiAxICkge1xyXG5cclxuXHRcdFx0aGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlciwgbykge1xyXG5cclxuXHRcdFx0XHR2YXIgdG8gPSBjaGVja0hhbmRsZVBvc2l0aW9uKHByb3Bvc2FscywgaGFuZGxlTnVtYmVyLCBwcm9wb3NhbHNbaGFuZGxlTnVtYmVyXSArIHByb3Bvc2FsLCBiW29dLCBmW29dKTtcclxuXHJcblx0XHRcdFx0Ly8gU3RvcCBpZiBvbmUgb2YgdGhlIGhhbmRsZXMgY2FuJ3QgbW92ZS5cclxuXHRcdFx0XHRpZiAoIHRvID09PSBmYWxzZSApIHtcclxuXHRcdFx0XHRcdHByb3Bvc2FsID0gMDtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cHJvcG9zYWwgPSB0byAtIHByb3Bvc2Fsc1toYW5kbGVOdW1iZXJdO1xyXG5cdFx0XHRcdFx0cHJvcG9zYWxzW2hhbmRsZU51bWJlcl0gPSB0bztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIElmIHVzaW5nIG9uZSBoYW5kbGUsIGNoZWNrIGJhY2t3YXJkIEFORCBmb3J3YXJkXHJcblx0XHRlbHNlIHtcclxuXHRcdFx0YiA9IGYgPSBbdHJ1ZV07XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHN0YXRlID0gZmFsc2U7XHJcblxyXG5cdFx0Ly8gU3RlcCAyOiBUcnkgdG8gc2V0IHRoZSBoYW5kbGVzIHdpdGggdGhlIGZvdW5kIHBlcmNlbnRhZ2VcclxuXHRcdGhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVOdW1iZXIsIG8pIHtcclxuXHRcdFx0c3RhdGUgPSBzZXRIYW5kbGUoaGFuZGxlTnVtYmVyLCBsb2NhdGlvbnNbaGFuZGxlTnVtYmVyXSArIHByb3Bvc2FsLCBiW29dLCBmW29dKSB8fCBzdGF0ZTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIFN0ZXAgMzogSWYgYSBoYW5kbGUgbW92ZWQsIGZpcmUgZXZlbnRzXHJcblx0XHRpZiAoIHN0YXRlICkge1xyXG5cdFx0XHRoYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlTnVtYmVyKXtcclxuXHRcdFx0XHRmaXJlRXZlbnQoJ3VwZGF0ZScsIGhhbmRsZU51bWJlcik7XHJcblx0XHRcdFx0ZmlyZUV2ZW50KCdzbGlkZScsIGhhbmRsZU51bWJlcik7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gRXh0ZXJuYWwgZXZlbnQgaGFuZGxpbmdcclxuXHRmdW5jdGlvbiBmaXJlRXZlbnQgKCBldmVudE5hbWUsIGhhbmRsZU51bWJlciwgdGFwICkge1xyXG5cclxuXHRcdE9iamVjdC5rZXlzKHNjb3BlX0V2ZW50cykuZm9yRWFjaChmdW5jdGlvbiggdGFyZ2V0RXZlbnQgKSB7XHJcblxyXG5cdFx0XHR2YXIgZXZlbnRUeXBlID0gdGFyZ2V0RXZlbnQuc3BsaXQoJy4nKVswXTtcclxuXHJcblx0XHRcdGlmICggZXZlbnROYW1lID09PSBldmVudFR5cGUgKSB7XHJcblx0XHRcdFx0c2NvcGVfRXZlbnRzW3RhcmdldEV2ZW50XS5mb3JFYWNoKGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcclxuXHJcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKFxyXG5cdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNsaWRlciBwdWJsaWMgQVBJIGFzIHRoZSBzY29wZSAoJ3RoaXMnKVxyXG5cdFx0XHRcdFx0XHRzY29wZV9TZWxmLFxyXG5cdFx0XHRcdFx0XHQvLyBSZXR1cm4gdmFsdWVzIGFzIGFycmF5LCBzbyBhcmdfMVthcmdfMl0gaXMgYWx3YXlzIHZhbGlkLlxyXG5cdFx0XHRcdFx0XHRzY29wZV9WYWx1ZXMubWFwKG9wdGlvbnMuZm9ybWF0LnRvKSxcclxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGluZGV4LCAwIG9yIDFcclxuXHRcdFx0XHRcdFx0aGFuZGxlTnVtYmVyLFxyXG5cdFx0XHRcdFx0XHQvLyBVbmZvcm1hdHRlZCBzbGlkZXIgdmFsdWVzXHJcblx0XHRcdFx0XHRcdHNjb3BlX1ZhbHVlcy5zbGljZSgpLFxyXG5cdFx0XHRcdFx0XHQvLyBFdmVudCBpcyBmaXJlZCBieSB0YXAsIHRydWUgb3IgZmFsc2VcclxuXHRcdFx0XHRcdFx0dGFwIHx8IGZhbHNlLFxyXG5cdFx0XHRcdFx0XHQvLyBMZWZ0IG9mZnNldCBvZiB0aGUgaGFuZGxlLCBpbiByZWxhdGlvbiB0byB0aGUgc2xpZGVyXHJcblx0XHRcdFx0XHRcdHNjb3BlX0xvY2F0aW9ucy5zbGljZSgpXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cclxuXHQvLyBGaXJlICdlbmQnIHdoZW4gYSBtb3VzZSBvciBwZW4gbGVhdmVzIHRoZSBkb2N1bWVudC5cclxuXHRmdW5jdGlvbiBkb2N1bWVudExlYXZlICggZXZlbnQsIGRhdGEgKSB7XHJcblx0XHRpZiAoIGV2ZW50LnR5cGUgPT09IFwibW91c2VvdXRcIiAmJiBldmVudC50YXJnZXQubm9kZU5hbWUgPT09IFwiSFRNTFwiICYmIGV2ZW50LnJlbGF0ZWRUYXJnZXQgPT09IG51bGwgKXtcclxuXHRcdFx0ZXZlbnRFbmQgKGV2ZW50LCBkYXRhKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIEhhbmRsZSBtb3ZlbWVudCBvbiBkb2N1bWVudCBmb3IgaGFuZGxlIGFuZCByYW5nZSBkcmFnLlxyXG5cdGZ1bmN0aW9uIGV2ZW50TW92ZSAoIGV2ZW50LCBkYXRhICkge1xyXG5cclxuXHRcdC8vIEZpeCAjNDk4XHJcblx0XHQvLyBDaGVjayB2YWx1ZSBvZiAuYnV0dG9ucyBpbiAnc3RhcnQnIHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluIElFMTAgbW9iaWxlIChkYXRhLmJ1dHRvbnNQcm9wZXJ0eSkuXHJcblx0XHQvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzkyNzAwNS9tb2JpbGUtaWUxMC13aW5kb3dzLXBob25lLWJ1dHRvbnMtcHJvcGVydHktb2YtcG9pbnRlcm1vdmUtZXZlbnQtYWx3YXlzLXplcm9cclxuXHRcdC8vIElFOSBoYXMgLmJ1dHRvbnMgYW5kIC53aGljaCB6ZXJvIG9uIG1vdXNlbW92ZS5cclxuXHRcdC8vIEZpcmVmb3ggYnJlYWtzIHRoZSBzcGVjIE1ETiBkZWZpbmVzLlxyXG5cdFx0aWYgKCBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKFwiTVNJRSA5XCIpID09PSAtMSAmJiBldmVudC5idXR0b25zID09PSAwICYmIGRhdGEuYnV0dG9uc1Byb3BlcnR5ICE9PSAwICkge1xyXG5cdFx0XHRyZXR1cm4gZXZlbnRFbmQoZXZlbnQsIGRhdGEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENoZWNrIGlmIHdlIGFyZSBtb3ZpbmcgdXAgb3IgZG93blxyXG5cdFx0dmFyIG1vdmVtZW50ID0gKG9wdGlvbnMuZGlyID8gLTEgOiAxKSAqIChldmVudC5jYWxjUG9pbnQgLSBkYXRhLnN0YXJ0Q2FsY1BvaW50KTtcclxuXHJcblx0XHQvLyBDb252ZXJ0IHRoZSBtb3ZlbWVudCBpbnRvIGEgcGVyY2VudGFnZSBvZiB0aGUgc2xpZGVyIHdpZHRoL2hlaWdodFxyXG5cdFx0dmFyIHByb3Bvc2FsID0gKG1vdmVtZW50ICogMTAwKSAvIGRhdGEuYmFzZVNpemU7XHJcblxyXG5cdFx0bW92ZUhhbmRsZXMobW92ZW1lbnQgPiAwLCBwcm9wb3NhbCwgZGF0YS5sb2NhdGlvbnMsIGRhdGEuaGFuZGxlTnVtYmVycyk7XHJcblx0fVxyXG5cclxuXHQvLyBVbmJpbmQgbW92ZSBldmVudHMgb24gZG9jdW1lbnQsIGNhbGwgY2FsbGJhY2tzLlxyXG5cdGZ1bmN0aW9uIGV2ZW50RW5kICggZXZlbnQsIGRhdGEgKSB7XHJcblxyXG5cdFx0Ly8gVGhlIGhhbmRsZSBpcyBubyBsb25nZXIgYWN0aXZlLCBzbyByZW1vdmUgdGhlIGNsYXNzLlxyXG5cdFx0aWYgKCBzY29wZV9BY3RpdmVIYW5kbGUgKSB7XHJcblx0XHRcdHJlbW92ZUNsYXNzKHNjb3BlX0FjdGl2ZUhhbmRsZSwgb3B0aW9ucy5jc3NDbGFzc2VzLmFjdGl2ZSk7XHJcblx0XHRcdHNjb3BlX0FjdGl2ZUhhbmRsZSA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFJlbW92ZSBjdXJzb3Igc3R5bGVzIGFuZCB0ZXh0LXNlbGVjdGlvbiBldmVudHMgYm91bmQgdG8gdGhlIGJvZHkuXHJcblx0XHRpZiAoIGV2ZW50LmN1cnNvciApIHtcclxuXHRcdFx0ZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAnJztcclxuXHRcdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIGRvY3VtZW50LmJvZHkubm9VaUxpc3RlbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBVbmJpbmQgdGhlIG1vdmUgYW5kIGVuZCBldmVudHMsIHdoaWNoIGFyZSBhZGRlZCBvbiAnc3RhcnQnLlxyXG5cdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm5vVWlMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiggYyApIHtcclxuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoY1swXSwgY1sxXSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBSZW1vdmUgZHJhZ2dpbmcgY2xhc3MuXHJcblx0XHRyZW1vdmVDbGFzcyhzY29wZV9UYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5kcmFnKTtcclxuXHJcblx0XHRzZXRaaW5kZXgoKTtcclxuXHJcblx0XHRkYXRhLmhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVOdW1iZXIpe1xyXG5cdFx0XHRmaXJlRXZlbnQoJ3NldCcsIGhhbmRsZU51bWJlcik7XHJcblx0XHRcdGZpcmVFdmVudCgnY2hhbmdlJywgaGFuZGxlTnVtYmVyKTtcclxuXHRcdFx0ZmlyZUV2ZW50KCdlbmQnLCBoYW5kbGVOdW1iZXIpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHQvLyBCaW5kIG1vdmUgZXZlbnRzIG9uIGRvY3VtZW50LlxyXG5cdGZ1bmN0aW9uIGV2ZW50U3RhcnQgKCBldmVudCwgZGF0YSApIHtcclxuXHJcblx0XHRpZiAoIGRhdGEuaGFuZGxlTnVtYmVycy5sZW5ndGggPT09IDEgKSB7XHJcblxyXG5cdFx0XHR2YXIgaGFuZGxlID0gc2NvcGVfSGFuZGxlc1tkYXRhLmhhbmRsZU51bWJlcnNbMF1dO1xyXG5cclxuXHRcdFx0Ly8gSWdub3JlICdkaXNhYmxlZCcgaGFuZGxlc1xyXG5cdFx0XHRpZiAoIGhhbmRsZS5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBNYXJrIHRoZSBoYW5kbGUgYXMgJ2FjdGl2ZScgc28gaXQgY2FuIGJlIHN0eWxlZC5cclxuXHRcdFx0c2NvcGVfQWN0aXZlSGFuZGxlID0gaGFuZGxlLmNoaWxkcmVuWzBdO1xyXG5cdFx0XHRhZGRDbGFzcyhzY29wZV9BY3RpdmVIYW5kbGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5hY3RpdmUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEZpeCAjNTUxLCB3aGVyZSBhIGhhbmRsZSBnZXRzIHNlbGVjdGVkIGluc3RlYWQgb2YgZHJhZ2dlZC5cclxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG5cdFx0Ly8gQSBkcmFnIHNob3VsZCBuZXZlciBwcm9wYWdhdGUgdXAgdG8gdGhlICd0YXAnIGV2ZW50LlxyXG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG5cdFx0Ly8gQXR0YWNoIHRoZSBtb3ZlIGFuZCBlbmQgZXZlbnRzLlxyXG5cdFx0dmFyIG1vdmVFdmVudCA9IGF0dGFjaEV2ZW50KGFjdGlvbnMubW92ZSwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBldmVudE1vdmUsIHtcclxuXHRcdFx0c3RhcnRDYWxjUG9pbnQ6IGV2ZW50LmNhbGNQb2ludCxcclxuXHRcdFx0YmFzZVNpemU6IGJhc2VTaXplKCksXHJcblx0XHRcdHBhZ2VPZmZzZXQ6IGV2ZW50LnBhZ2VPZmZzZXQsXHJcblx0XHRcdGhhbmRsZU51bWJlcnM6IGRhdGEuaGFuZGxlTnVtYmVycyxcclxuXHRcdFx0YnV0dG9uc1Byb3BlcnR5OiBldmVudC5idXR0b25zLFxyXG5cdFx0XHRsb2NhdGlvbnM6IHNjb3BlX0xvY2F0aW9ucy5zbGljZSgpXHJcblx0XHR9KTtcclxuXHJcblx0XHR2YXIgZW5kRXZlbnQgPSBhdHRhY2hFdmVudChhY3Rpb25zLmVuZCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBldmVudEVuZCwge1xyXG5cdFx0XHRoYW5kbGVOdW1iZXJzOiBkYXRhLmhhbmRsZU51bWJlcnNcclxuXHRcdH0pO1xyXG5cclxuXHRcdHZhciBvdXRFdmVudCA9IGF0dGFjaEV2ZW50KFwibW91c2VvdXRcIiwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBkb2N1bWVudExlYXZlLCB7XHJcblx0XHRcdGhhbmRsZU51bWJlcnM6IGRhdGEuaGFuZGxlTnVtYmVyc1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm5vVWlMaXN0ZW5lcnMgPSBtb3ZlRXZlbnQuY29uY2F0KGVuZEV2ZW50LCBvdXRFdmVudCk7XHJcblxyXG5cdFx0Ly8gVGV4dCBzZWxlY3Rpb24gaXNuJ3QgYW4gaXNzdWUgb24gdG91Y2ggZGV2aWNlcyxcclxuXHRcdC8vIHNvIGFkZGluZyBjdXJzb3Igc3R5bGVzIGNhbiBiZSBza2lwcGVkLlxyXG5cdFx0aWYgKCBldmVudC5jdXJzb3IgKSB7XHJcblxyXG5cdFx0XHQvLyBQcmV2ZW50IHRoZSAnSScgY3Vyc29yIGFuZCBleHRlbmQgdGhlIHJhbmdlLWRyYWcgY3Vyc29yLlxyXG5cdFx0XHRkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9IGdldENvbXB1dGVkU3R5bGUoZXZlbnQudGFyZ2V0KS5jdXJzb3I7XHJcblxyXG5cdFx0XHQvLyBNYXJrIHRoZSB0YXJnZXQgd2l0aCBhIGRyYWdnaW5nIHN0YXRlLlxyXG5cdFx0XHRpZiAoIHNjb3BlX0hhbmRsZXMubGVuZ3RoID4gMSApIHtcclxuXHRcdFx0XHRhZGRDbGFzcyhzY29wZV9UYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5kcmFnKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGYgPSBmdW5jdGlvbigpe1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGRvY3VtZW50LmJvZHkubm9VaUxpc3RlbmVyID0gZjtcclxuXHJcblx0XHRcdC8vIFByZXZlbnQgdGV4dCBzZWxlY3Rpb24gd2hlbiBkcmFnZ2luZyB0aGUgaGFuZGxlcy5cclxuXHRcdFx0ZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIGYsIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0XHRkYXRhLmhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVOdW1iZXIpe1xyXG5cdFx0XHRmaXJlRXZlbnQoJ3N0YXJ0JywgaGFuZGxlTnVtYmVyKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0Ly8gTW92ZSBjbG9zZXN0IGhhbmRsZSB0byB0YXBwZWQgbG9jYXRpb24uXHJcblx0ZnVuY3Rpb24gZXZlbnRUYXAgKCBldmVudCApIHtcclxuXHJcblx0XHQvLyBUaGUgdGFwIGV2ZW50IHNob3VsZG4ndCBwcm9wYWdhdGUgdXBcclxuXHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuXHRcdHZhciBwcm9wb3NhbCA9IGNhbGNQb2ludFRvUGVyY2VudGFnZShldmVudC5jYWxjUG9pbnQpO1xyXG5cdFx0dmFyIGhhbmRsZU51bWJlciA9IGdldENsb3Nlc3RIYW5kbGUocHJvcG9zYWwpO1xyXG5cclxuXHRcdC8vIFRhY2tsZSB0aGUgY2FzZSB0aGF0IGFsbCBoYW5kbGVzIGFyZSAnZGlzYWJsZWQnLlxyXG5cdFx0aWYgKCBoYW5kbGVOdW1iZXIgPT09IGZhbHNlICkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRmxhZyB0aGUgc2xpZGVyIGFzIGl0IGlzIG5vdyBpbiBhIHRyYW5zaXRpb25hbCBzdGF0ZS5cclxuXHRcdC8vIFRyYW5zaXRpb24gdGFrZXMgYSBjb25maWd1cmFibGUgYW1vdW50IG9mIG1zIChkZWZhdWx0IDMwMCkuIFJlLWVuYWJsZSB0aGUgc2xpZGVyIGFmdGVyIHRoYXQuXHJcblx0XHRpZiAoICFvcHRpb25zLmV2ZW50cy5zbmFwICkge1xyXG5cdFx0XHRhZGRDbGFzc0ZvcihzY29wZV9UYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50YXAsIG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHByb3Bvc2FsLCB0cnVlLCB0cnVlKTtcclxuXHJcblx0XHRzZXRaaW5kZXgoKTtcclxuXHJcblx0XHRmaXJlRXZlbnQoJ3NsaWRlJywgaGFuZGxlTnVtYmVyLCB0cnVlKTtcclxuXHRcdGZpcmVFdmVudCgnc2V0JywgaGFuZGxlTnVtYmVyLCB0cnVlKTtcclxuXHRcdGZpcmVFdmVudCgnY2hhbmdlJywgaGFuZGxlTnVtYmVyLCB0cnVlKTtcclxuXHRcdGZpcmVFdmVudCgndXBkYXRlJywgaGFuZGxlTnVtYmVyLCB0cnVlKTtcclxuXHJcblx0XHRpZiAoIG9wdGlvbnMuZXZlbnRzLnNuYXAgKSB7XHJcblx0XHRcdGV2ZW50U3RhcnQoZXZlbnQsIHsgaGFuZGxlTnVtYmVyczogW2hhbmRsZU51bWJlcl0gfSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBGaXJlcyBhICdob3ZlcicgZXZlbnQgZm9yIGEgaG92ZXJlZCBtb3VzZS9wZW4gcG9zaXRpb24uXHJcblx0ZnVuY3Rpb24gZXZlbnRIb3ZlciAoIGV2ZW50ICkge1xyXG5cclxuXHRcdHZhciBwcm9wb3NhbCA9IGNhbGNQb2ludFRvUGVyY2VudGFnZShldmVudC5jYWxjUG9pbnQpO1xyXG5cclxuXHRcdHZhciB0byA9IHNjb3BlX1NwZWN0cnVtLmdldFN0ZXAocHJvcG9zYWwpO1xyXG5cdFx0dmFyIHZhbHVlID0gc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKHRvKTtcclxuXHJcblx0XHRPYmplY3Qua2V5cyhzY29wZV9FdmVudHMpLmZvckVhY2goZnVuY3Rpb24oIHRhcmdldEV2ZW50ICkge1xyXG5cdFx0XHRpZiAoICdob3ZlcicgPT09IHRhcmdldEV2ZW50LnNwbGl0KCcuJylbMF0gKSB7XHJcblx0XHRcdFx0c2NvcGVfRXZlbnRzW3RhcmdldEV2ZW50XS5mb3JFYWNoKGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcclxuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoIHNjb3BlX1NlbGYsIHZhbHVlICk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0Ly8gQXR0YWNoIGV2ZW50cyB0byBzZXZlcmFsIHNsaWRlciBwYXJ0cy5cclxuXHRmdW5jdGlvbiBiaW5kU2xpZGVyRXZlbnRzICggYmVoYXZpb3VyICkge1xyXG5cclxuXHRcdC8vIEF0dGFjaCB0aGUgc3RhbmRhcmQgZHJhZyBldmVudCB0byB0aGUgaGFuZGxlcy5cclxuXHRcdGlmICggIWJlaGF2aW91ci5maXhlZCApIHtcclxuXHJcblx0XHRcdHNjb3BlX0hhbmRsZXMuZm9yRWFjaChmdW5jdGlvbiggaGFuZGxlLCBpbmRleCApe1xyXG5cclxuXHRcdFx0XHQvLyBUaGVzZSBldmVudHMgYXJlIG9ubHkgYm91bmQgdG8gdGhlIHZpc3VhbCBoYW5kbGVcclxuXHRcdFx0XHQvLyBlbGVtZW50LCBub3QgdGhlICdyZWFsJyBvcmlnaW4gZWxlbWVudC5cclxuXHRcdFx0XHRhdHRhY2hFdmVudCAoIGFjdGlvbnMuc3RhcnQsIGhhbmRsZS5jaGlsZHJlblswXSwgZXZlbnRTdGFydCwge1xyXG5cdFx0XHRcdFx0aGFuZGxlTnVtYmVyczogW2luZGV4XVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBBdHRhY2ggdGhlIHRhcCBldmVudCB0byB0aGUgc2xpZGVyIGJhc2UuXHJcblx0XHRpZiAoIGJlaGF2aW91ci50YXAgKSB7XHJcblx0XHRcdGF0dGFjaEV2ZW50IChhY3Rpb25zLnN0YXJ0LCBzY29wZV9CYXNlLCBldmVudFRhcCwge30pO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEZpcmUgaG92ZXIgZXZlbnRzXHJcblx0XHRpZiAoIGJlaGF2aW91ci5ob3ZlciApIHtcclxuXHRcdFx0YXR0YWNoRXZlbnQgKGFjdGlvbnMubW92ZSwgc2NvcGVfQmFzZSwgZXZlbnRIb3ZlciwgeyBob3ZlcjogdHJ1ZSB9KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBNYWtlIHRoZSByYW5nZSBkcmFnZ2FibGUuXHJcblx0XHRpZiAoIGJlaGF2aW91ci5kcmFnICl7XHJcblxyXG5cdFx0XHRzY29wZV9Db25uZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKCBjb25uZWN0LCBpbmRleCApe1xyXG5cclxuXHRcdFx0XHRpZiAoIGNvbm5lY3QgPT09IGZhbHNlIHx8IGluZGV4ID09PSAwIHx8IGluZGV4ID09PSBzY29wZV9Db25uZWN0cy5sZW5ndGggLSAxICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIGhhbmRsZUJlZm9yZSA9IHNjb3BlX0hhbmRsZXNbaW5kZXggLSAxXTtcclxuXHRcdFx0XHR2YXIgaGFuZGxlQWZ0ZXIgPSBzY29wZV9IYW5kbGVzW2luZGV4XTtcclxuXHRcdFx0XHR2YXIgZXZlbnRIb2xkZXJzID0gW2Nvbm5lY3RdO1xyXG5cclxuXHRcdFx0XHRhZGRDbGFzcyhjb25uZWN0LCBvcHRpb25zLmNzc0NsYXNzZXMuZHJhZ2dhYmxlKTtcclxuXHJcblx0XHRcdFx0Ly8gV2hlbiB0aGUgcmFuZ2UgaXMgZml4ZWQsIHRoZSBlbnRpcmUgcmFuZ2UgY2FuXHJcblx0XHRcdFx0Ly8gYmUgZHJhZ2dlZCBieSB0aGUgaGFuZGxlcy4gVGhlIGhhbmRsZSBpbiB0aGUgZmlyc3RcclxuXHRcdFx0XHQvLyBvcmlnaW4gd2lsbCBwcm9wYWdhdGUgdGhlIHN0YXJ0IGV2ZW50IHVwd2FyZCxcclxuXHRcdFx0XHQvLyBidXQgaXQgbmVlZHMgdG8gYmUgYm91bmQgbWFudWFsbHkgb24gdGhlIG90aGVyLlxyXG5cdFx0XHRcdGlmICggYmVoYXZpb3VyLmZpeGVkICkge1xyXG5cdFx0XHRcdFx0ZXZlbnRIb2xkZXJzLnB1c2goaGFuZGxlQmVmb3JlLmNoaWxkcmVuWzBdKTtcclxuXHRcdFx0XHRcdGV2ZW50SG9sZGVycy5wdXNoKGhhbmRsZUFmdGVyLmNoaWxkcmVuWzBdKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGV2ZW50SG9sZGVycy5mb3JFYWNoKGZ1bmN0aW9uKCBldmVudEhvbGRlciApIHtcclxuXHRcdFx0XHRcdGF0dGFjaEV2ZW50ICggYWN0aW9ucy5zdGFydCwgZXZlbnRIb2xkZXIsIGV2ZW50U3RhcnQsIHtcclxuXHRcdFx0XHRcdFx0aGFuZGxlczogW2hhbmRsZUJlZm9yZSwgaGFuZGxlQWZ0ZXJdLFxyXG5cdFx0XHRcdFx0XHRoYW5kbGVOdW1iZXJzOiBbaW5kZXggLSAxLCBpbmRleF1cclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cclxuXHQvLyBTcGxpdCBvdXQgdGhlIGhhbmRsZSBwb3NpdGlvbmluZyBsb2dpYyBzbyB0aGUgTW92ZSBldmVudCBjYW4gdXNlIGl0LCB0b29cclxuXHRmdW5jdGlvbiBjaGVja0hhbmRsZVBvc2l0aW9uICggcmVmZXJlbmNlLCBoYW5kbGVOdW1iZXIsIHRvLCBsb29rQmFja3dhcmQsIGxvb2tGb3J3YXJkICkge1xyXG5cclxuXHRcdC8vIEZvciBzbGlkZXJzIHdpdGggbXVsdGlwbGUgaGFuZGxlcywgbGltaXQgbW92ZW1lbnQgdG8gdGhlIG90aGVyIGhhbmRsZS5cclxuXHRcdC8vIEFwcGx5IHRoZSBtYXJnaW4gb3B0aW9uIGJ5IGFkZGluZyBpdCB0byB0aGUgaGFuZGxlIHBvc2l0aW9ucy5cclxuXHRcdGlmICggc2NvcGVfSGFuZGxlcy5sZW5ndGggPiAxICkge1xyXG5cclxuXHRcdFx0aWYgKCBsb29rQmFja3dhcmQgJiYgaGFuZGxlTnVtYmVyID4gMCApIHtcclxuXHRcdFx0XHR0byA9IE1hdGgubWF4KHRvLCByZWZlcmVuY2VbaGFuZGxlTnVtYmVyIC0gMV0gKyBvcHRpb25zLm1hcmdpbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbG9va0ZvcndhcmQgJiYgaGFuZGxlTnVtYmVyIDwgc2NvcGVfSGFuZGxlcy5sZW5ndGggLSAxICkge1xyXG5cdFx0XHRcdHRvID0gTWF0aC5taW4odG8sIHJlZmVyZW5jZVtoYW5kbGVOdW1iZXIgKyAxXSAtIG9wdGlvbnMubWFyZ2luKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRoZSBsaW1pdCBvcHRpb24gaGFzIHRoZSBvcHBvc2l0ZSBlZmZlY3QsIGxpbWl0aW5nIGhhbmRsZXMgdG8gYVxyXG5cdFx0Ly8gbWF4aW11bSBkaXN0YW5jZSBmcm9tIGFub3RoZXIuIExpbWl0IG11c3QgYmUgPiAwLCBhcyBvdGhlcndpc2VcclxuXHRcdC8vIGhhbmRsZXMgd291bGQgYmUgdW5tb3ZlYWJsZS5cclxuXHRcdGlmICggc2NvcGVfSGFuZGxlcy5sZW5ndGggPiAxICYmIG9wdGlvbnMubGltaXQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGxvb2tCYWNrd2FyZCAmJiBoYW5kbGVOdW1iZXIgPiAwICkge1xyXG5cdFx0XHRcdHRvID0gTWF0aC5taW4odG8sIHJlZmVyZW5jZVtoYW5kbGVOdW1iZXIgLSAxXSArIG9wdGlvbnMubGltaXQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGxvb2tGb3J3YXJkICYmIGhhbmRsZU51bWJlciA8IHNjb3BlX0hhbmRsZXMubGVuZ3RoIC0gMSApIHtcclxuXHRcdFx0XHR0byA9IE1hdGgubWF4KHRvLCByZWZlcmVuY2VbaGFuZGxlTnVtYmVyICsgMV0gLSBvcHRpb25zLmxpbWl0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRoZSBwYWRkaW5nIG9wdGlvbiBrZWVwcyB0aGUgaGFuZGxlcyBhIGNlcnRhaW4gZGlzdGFuY2UgZnJvbSB0aGVcclxuXHRcdC8vIGVkZ2VzIG9mIHRoZSBzbGlkZXIuIFBhZGRpbmcgbXVzdCBiZSA+IDAuXHJcblx0XHRpZiAoIG9wdGlvbnMucGFkZGluZyApIHtcclxuXHJcblx0XHRcdGlmICggaGFuZGxlTnVtYmVyID09PSAwICkge1xyXG5cdFx0XHRcdHRvID0gTWF0aC5tYXgodG8sIG9wdGlvbnMucGFkZGluZyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggaGFuZGxlTnVtYmVyID09PSBzY29wZV9IYW5kbGVzLmxlbmd0aCAtIDEgKSB7XHJcblx0XHRcdFx0dG8gPSBNYXRoLm1pbih0bywgMTAwIC0gb3B0aW9ucy5wYWRkaW5nKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRvID0gc2NvcGVfU3BlY3RydW0uZ2V0U3RlcCh0byk7XHJcblxyXG5cdFx0Ly8gTGltaXQgcGVyY2VudGFnZSB0byB0aGUgMCAtIDEwMCByYW5nZVxyXG5cdFx0dG8gPSBsaW1pdCh0byk7XHJcblxyXG5cdFx0Ly8gUmV0dXJuIGZhbHNlIGlmIGhhbmRsZSBjYW4ndCBtb3ZlXHJcblx0XHRpZiAoIHRvID09PSByZWZlcmVuY2VbaGFuZGxlTnVtYmVyXSApIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0bztcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRvUGN0ICggcGN0ICkge1xyXG5cdFx0cmV0dXJuIHBjdCArICclJztcclxuXHR9XHJcblxyXG5cdC8vIFVwZGF0ZXMgc2NvcGVfTG9jYXRpb25zIGFuZCBzY29wZV9WYWx1ZXMsIHVwZGF0ZXMgdmlzdWFsIHN0YXRlXHJcblx0ZnVuY3Rpb24gdXBkYXRlSGFuZGxlUG9zaXRpb24gKCBoYW5kbGVOdW1iZXIsIHRvICkge1xyXG5cclxuXHRcdC8vIFVwZGF0ZSBsb2NhdGlvbnMuXHJcblx0XHRzY29wZV9Mb2NhdGlvbnNbaGFuZGxlTnVtYmVyXSA9IHRvO1xyXG5cclxuXHRcdC8vIENvbnZlcnQgdGhlIHZhbHVlIHRvIHRoZSBzbGlkZXIgc3RlcHBpbmcvcmFuZ2UuXHJcblx0XHRzY29wZV9WYWx1ZXNbaGFuZGxlTnVtYmVyXSA9IHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyh0byk7XHJcblxyXG5cdFx0Ly8gQ2FsbGVkIHN5bmNocm9ub3VzbHkgb3Igb24gdGhlIG5leHQgYW5pbWF0aW9uRnJhbWVcclxuXHRcdHZhciBzdGF0ZVVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRzY29wZV9IYW5kbGVzW2hhbmRsZU51bWJlcl0uc3R5bGVbb3B0aW9ucy5zdHlsZV0gPSB0b1BjdCh0byk7XHJcblx0XHRcdHVwZGF0ZUNvbm5lY3QoaGFuZGxlTnVtYmVyKTtcclxuXHRcdFx0dXBkYXRlQ29ubmVjdChoYW5kbGVOdW1iZXIgKyAxKTtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gU2V0IHRoZSBoYW5kbGUgdG8gdGhlIG5ldyBwb3NpdGlvbi5cclxuXHRcdC8vIFVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZm9yIGVmZmljaWVudCBwYWludGluZy5cclxuXHRcdC8vIE5vIHNpZ25pZmljYW50IGVmZmVjdCBpbiBDaHJvbWUsIEVkZ2Ugc2VlcyBkcmFtYXRpYyBwZXJmb3JtYWNlIGltcHJvdmVtZW50cy5cclxuXHRcdC8vIE9wdGlvbiB0byBkaXNhYmxlIGlzIHVzZWZ1bCBmb3IgdW5pdCB0ZXN0cywgYW5kIHNpbmdsZS1zdGVwIGRlYnVnZ2luZy5cclxuXHRcdGlmICggd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAmJiBvcHRpb25zLnVzZVJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcclxuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShzdGF0ZVVwZGF0ZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdGF0ZVVwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0WmluZGV4ICggKSB7XHJcblxyXG5cdFx0c2NvcGVfSGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlcil7XHJcblx0XHRcdC8vIEhhbmRsZXMgYmVmb3JlIHRoZSBzbGlkZXIgbWlkZGxlIGFyZSBzdGFja2VkIGxhdGVyID0gaGlnaGVyLFxyXG5cdFx0XHQvLyBIYW5kbGVzIGFmdGVyIHRoZSBtaWRkbGUgbGF0ZXIgaXMgbG93ZXJcclxuXHRcdFx0Ly8gW1s3XSBbOF0gLi4uLi4uLi4uLiB8IC4uLi4uLi4uLi4gWzVdIFs0XVxyXG5cdFx0XHR2YXIgZGlyID0gKHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdID4gNTAgPyAtMSA6IDEpO1xyXG5cdFx0XHR2YXIgekluZGV4ID0gMyArIChzY29wZV9IYW5kbGVzLmxlbmd0aCArIChkaXIgKiBoYW5kbGVOdW1iZXIpKTtcclxuXHRcdFx0c2NvcGVfSGFuZGxlc1toYW5kbGVOdW1iZXJdLmNoaWxkTm9kZXNbMF0uc3R5bGUuekluZGV4ID0gekluZGV4O1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHQvLyBUZXN0IHN1Z2dlc3RlZCB2YWx1ZXMgYW5kIGFwcGx5IG1hcmdpbiwgc3RlcC5cclxuXHRmdW5jdGlvbiBzZXRIYW5kbGUgKCBoYW5kbGVOdW1iZXIsIHRvLCBsb29rQmFja3dhcmQsIGxvb2tGb3J3YXJkICkge1xyXG5cclxuXHRcdHRvID0gY2hlY2tIYW5kbGVQb3NpdGlvbihzY29wZV9Mb2NhdGlvbnMsIGhhbmRsZU51bWJlciwgdG8sIGxvb2tCYWNrd2FyZCwgbG9va0ZvcndhcmQpO1xyXG5cclxuXHRcdGlmICggdG8gPT09IGZhbHNlICkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0dXBkYXRlSGFuZGxlUG9zaXRpb24oaGFuZGxlTnVtYmVyLCB0byk7XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cclxuXHQvLyBVcGRhdGVzIHN0eWxlIGF0dHJpYnV0ZSBmb3IgY29ubmVjdCBub2Rlc1xyXG5cdGZ1bmN0aW9uIHVwZGF0ZUNvbm5lY3QgKCBpbmRleCApIHtcclxuXHJcblx0XHQvLyBTa2lwIGNvbm5lY3RzIHNldCB0byBmYWxzZVxyXG5cdFx0aWYgKCAhc2NvcGVfQ29ubmVjdHNbaW5kZXhdICkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGwgPSAwO1xyXG5cdFx0dmFyIGggPSAxMDA7XHJcblxyXG5cdFx0aWYgKCBpbmRleCAhPT0gMCApIHtcclxuXHRcdFx0bCA9IHNjb3BlX0xvY2F0aW9uc1tpbmRleCAtIDFdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggaW5kZXggIT09IHNjb3BlX0Nvbm5lY3RzLmxlbmd0aCAtIDEgKSB7XHJcblx0XHRcdGggPSBzY29wZV9Mb2NhdGlvbnNbaW5kZXhdO1xyXG5cdFx0fVxyXG5cclxuXHRcdHNjb3BlX0Nvbm5lY3RzW2luZGV4XS5zdHlsZVtvcHRpb25zLnN0eWxlXSA9IHRvUGN0KGwpO1xyXG5cdFx0c2NvcGVfQ29ubmVjdHNbaW5kZXhdLnN0eWxlW29wdGlvbnMuc3R5bGVPcG9zaXRlXSA9IHRvUGN0KDEwMCAtIGgpO1xyXG5cdH1cclxuXHJcblx0Ly8gLi4uXHJcblx0ZnVuY3Rpb24gc2V0VmFsdWUgKCB0bywgaGFuZGxlTnVtYmVyICkge1xyXG5cclxuXHRcdC8vIFNldHRpbmcgd2l0aCBudWxsIGluZGljYXRlcyBhbiAnaWdub3JlJy5cclxuXHRcdC8vIElucHV0dGluZyAnZmFsc2UnIGlzIGludmFsaWQuXHJcblx0XHRpZiAoIHRvID09PSBudWxsIHx8IHRvID09PSBmYWxzZSApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIElmIGEgZm9ybWF0dGVkIG51bWJlciB3YXMgcGFzc2VkLCBhdHRlbXQgdG8gZGVjb2RlIGl0LlxyXG5cdFx0aWYgKCB0eXBlb2YgdG8gPT09ICdudW1iZXInICkge1xyXG5cdFx0XHR0byA9IFN0cmluZyh0byk7XHJcblx0XHR9XHJcblxyXG5cdFx0dG8gPSBvcHRpb25zLmZvcm1hdC5mcm9tKHRvKTtcclxuXHJcblx0XHQvLyBSZXF1ZXN0IGFuIHVwZGF0ZSBmb3IgYWxsIGxpbmtzIGlmIHRoZSB2YWx1ZSB3YXMgaW52YWxpZC5cclxuXHRcdC8vIERvIHNvIHRvbyBpZiBzZXR0aW5nIHRoZSBoYW5kbGUgZmFpbHMuXHJcblx0XHRpZiAoIHRvICE9PSBmYWxzZSAmJiAhaXNOYU4odG8pICkge1xyXG5cdFx0XHRzZXRIYW5kbGUoaGFuZGxlTnVtYmVyLCBzY29wZV9TcGVjdHJ1bS50b1N0ZXBwaW5nKHRvKSwgZmFsc2UsIGZhbHNlKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIFNldCB0aGUgc2xpZGVyIHZhbHVlLlxyXG5cdGZ1bmN0aW9uIHZhbHVlU2V0ICggaW5wdXQsIGZpcmVTZXRFdmVudCApIHtcclxuXHJcblx0XHR2YXIgdmFsdWVzID0gYXNBcnJheShpbnB1dCk7XHJcblx0XHR2YXIgaXNJbml0ID0gc2NvcGVfTG9jYXRpb25zWzBdID09PSB1bmRlZmluZWQ7XHJcblxyXG5cdFx0Ly8gRXZlbnQgZmlyZXMgYnkgZGVmYXVsdFxyXG5cdFx0ZmlyZVNldEV2ZW50ID0gKGZpcmVTZXRFdmVudCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhZmlyZVNldEV2ZW50KTtcclxuXHJcblx0XHR2YWx1ZXMuZm9yRWFjaChzZXRWYWx1ZSk7XHJcblxyXG5cdFx0Ly8gQW5pbWF0aW9uIGlzIG9wdGlvbmFsLlxyXG5cdFx0Ly8gTWFrZSBzdXJlIHRoZSBpbml0aWFsIHZhbHVlcyB3ZXJlIHNldCBiZWZvcmUgdXNpbmcgYW5pbWF0ZWQgcGxhY2VtZW50LlxyXG5cdFx0aWYgKCBvcHRpb25zLmFuaW1hdGUgJiYgIWlzSW5pdCApIHtcclxuXHRcdFx0YWRkQ2xhc3NGb3Ioc2NvcGVfVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMudGFwLCBvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBOb3cgdGhhdCBhbGwgYmFzZSB2YWx1ZXMgYXJlIHNldCwgYXBwbHkgY29uc3RyYWludHNcclxuXHRcdHNjb3BlX0hhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVOdW1iZXIpe1xyXG5cdFx0XHRzZXRIYW5kbGUoaGFuZGxlTnVtYmVyLCBzY29wZV9Mb2NhdGlvbnNbaGFuZGxlTnVtYmVyXSwgdHJ1ZSwgZmFsc2UpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0c2V0WmluZGV4KCk7XHJcblxyXG5cdFx0c2NvcGVfSGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlcil7XHJcblxyXG5cdFx0XHRmaXJlRXZlbnQoJ3VwZGF0ZScsIGhhbmRsZU51bWJlcik7XHJcblxyXG5cdFx0XHQvLyBGaXJlIHRoZSBldmVudCBvbmx5IGZvciBoYW5kbGVzIHRoYXQgcmVjZWl2ZWQgYSBuZXcgdmFsdWUsIGFzIHBlciAjNTc5XHJcblx0XHRcdGlmICggdmFsdWVzW2hhbmRsZU51bWJlcl0gIT09IG51bGwgJiYgZmlyZVNldEV2ZW50ICkge1xyXG5cdFx0XHRcdGZpcmVFdmVudCgnc2V0JywgaGFuZGxlTnVtYmVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHQvLyBSZXNldCBzbGlkZXIgdG8gaW5pdGlhbCB2YWx1ZXNcclxuXHRmdW5jdGlvbiB2YWx1ZVJlc2V0ICggZmlyZVNldEV2ZW50ICkge1xyXG5cdFx0dmFsdWVTZXQob3B0aW9ucy5zdGFydCwgZmlyZVNldEV2ZW50KTtcclxuXHR9XHJcblxyXG5cdC8vIEdldCB0aGUgc2xpZGVyIHZhbHVlLlxyXG5cdGZ1bmN0aW9uIHZhbHVlR2V0ICggKSB7XHJcblxyXG5cdFx0dmFyIHZhbHVlcyA9IHNjb3BlX1ZhbHVlcy5tYXAob3B0aW9ucy5mb3JtYXQudG8pO1xyXG5cclxuXHRcdC8vIElmIG9ubHkgb25lIGhhbmRsZSBpcyB1c2VkLCByZXR1cm4gYSBzaW5nbGUgdmFsdWUuXHJcblx0XHRpZiAoIHZhbHVlcy5sZW5ndGggPT09IDEgKXtcclxuXHRcdFx0cmV0dXJuIHZhbHVlc1swXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdmFsdWVzO1xyXG5cdH1cclxuXHJcblx0Ly8gUmVtb3ZlcyBjbGFzc2VzIGZyb20gdGhlIHJvb3QgYW5kIGVtcHRpZXMgaXQuXHJcblx0ZnVuY3Rpb24gZGVzdHJveSAoICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBrZXkgaW4gb3B0aW9ucy5jc3NDbGFzc2VzICkge1xyXG5cdFx0XHRpZiAoICFvcHRpb25zLmNzc0NsYXNzZXMuaGFzT3duUHJvcGVydHkoa2V5KSApIHsgY29udGludWU7IH1cclxuXHRcdFx0cmVtb3ZlQ2xhc3Moc2NvcGVfVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXNba2V5XSk7XHJcblx0XHR9XHJcblxyXG5cdFx0d2hpbGUgKHNjb3BlX1RhcmdldC5maXJzdENoaWxkKSB7XHJcblx0XHRcdHNjb3BlX1RhcmdldC5yZW1vdmVDaGlsZChzY29wZV9UYXJnZXQuZmlyc3RDaGlsZCk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGVsZXRlIHNjb3BlX1RhcmdldC5ub1VpU2xpZGVyO1xyXG5cdH1cclxuXHJcblx0Ly8gR2V0IHRoZSBjdXJyZW50IHN0ZXAgc2l6ZSBmb3IgdGhlIHNsaWRlci5cclxuXHRmdW5jdGlvbiBnZXRDdXJyZW50U3RlcCAoICkge1xyXG5cclxuXHRcdC8vIENoZWNrIGFsbCBsb2NhdGlvbnMsIG1hcCB0aGVtIHRvIHRoZWlyIHN0ZXBwaW5nIHBvaW50LlxyXG5cdFx0Ly8gR2V0IHRoZSBzdGVwIHBvaW50LCB0aGVuIGZpbmQgaXQgaW4gdGhlIGlucHV0IGxpc3QuXHJcblx0XHRyZXR1cm4gc2NvcGVfTG9jYXRpb25zLm1hcChmdW5jdGlvbiggbG9jYXRpb24sIGluZGV4ICl7XHJcblxyXG5cdFx0XHR2YXIgbmVhcmJ5U3RlcHMgPSBzY29wZV9TcGVjdHJ1bS5nZXROZWFyYnlTdGVwcyggbG9jYXRpb24gKTtcclxuXHRcdFx0dmFyIHZhbHVlID0gc2NvcGVfVmFsdWVzW2luZGV4XTtcclxuXHRcdFx0dmFyIGluY3JlbWVudCA9IG5lYXJieVN0ZXBzLnRoaXNTdGVwLnN0ZXA7XHJcblx0XHRcdHZhciBkZWNyZW1lbnQgPSBudWxsO1xyXG5cclxuXHRcdFx0Ly8gSWYgdGhlIG5leHQgdmFsdWUgaW4gdGhpcyBzdGVwIG1vdmVzIGludG8gdGhlIG5leHQgc3RlcCxcclxuXHRcdFx0Ly8gdGhlIGluY3JlbWVudCBpcyB0aGUgc3RhcnQgb2YgdGhlIG5leHQgc3RlcCAtIHRoZSBjdXJyZW50IHZhbHVlXHJcblx0XHRcdGlmICggaW5jcmVtZW50ICE9PSBmYWxzZSApIHtcclxuXHRcdFx0XHRpZiAoIHZhbHVlICsgaW5jcmVtZW50ID4gbmVhcmJ5U3RlcHMuc3RlcEFmdGVyLnN0YXJ0VmFsdWUgKSB7XHJcblx0XHRcdFx0XHRpbmNyZW1lbnQgPSBuZWFyYnlTdGVwcy5zdGVwQWZ0ZXIuc3RhcnRWYWx1ZSAtIHZhbHVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdC8vIElmIHRoZSB2YWx1ZSBpcyBiZXlvbmQgdGhlIHN0YXJ0aW5nIHBvaW50XHJcblx0XHRcdGlmICggdmFsdWUgPiBuZWFyYnlTdGVwcy50aGlzU3RlcC5zdGFydFZhbHVlICkge1xyXG5cdFx0XHRcdGRlY3JlbWVudCA9IG5lYXJieVN0ZXBzLnRoaXNTdGVwLnN0ZXA7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGVsc2UgaWYgKCBuZWFyYnlTdGVwcy5zdGVwQmVmb3JlLnN0ZXAgPT09IGZhbHNlICkge1xyXG5cdFx0XHRcdGRlY3JlbWVudCA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBJZiBhIGhhbmRsZSBpcyBhdCB0aGUgc3RhcnQgb2YgYSBzdGVwLCBpdCBhbHdheXMgc3RlcHMgYmFjayBpbnRvIHRoZSBwcmV2aW91cyBzdGVwIGZpcnN0XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGRlY3JlbWVudCA9IHZhbHVlIC0gbmVhcmJ5U3RlcHMuc3RlcEJlZm9yZS5oaWdoZXN0U3RlcDtcclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdC8vIE5vdywgaWYgYXQgdGhlIHNsaWRlciBlZGdlcywgdGhlcmUgaXMgbm90IGluL2RlY3JlbWVudFxyXG5cdFx0XHRpZiAoIGxvY2F0aW9uID09PSAxMDAgKSB7XHJcblx0XHRcdFx0aW5jcmVtZW50ID0gbnVsbDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZWxzZSBpZiAoIGxvY2F0aW9uID09PSAwICkge1xyXG5cdFx0XHRcdGRlY3JlbWVudCA9IG51bGw7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEFzIHBlciAjMzkxLCB0aGUgY29tcGFyaXNvbiBmb3IgdGhlIGRlY3JlbWVudCBzdGVwIGNhbiBoYXZlIHNvbWUgcm91bmRpbmcgaXNzdWVzLlxyXG5cdFx0XHR2YXIgc3RlcERlY2ltYWxzID0gc2NvcGVfU3BlY3RydW0uY291bnRTdGVwRGVjaW1hbHMoKTtcclxuXHJcblx0XHRcdC8vIFJvdW5kIHBlciAjMzkxXHJcblx0XHRcdGlmICggaW5jcmVtZW50ICE9PSBudWxsICYmIGluY3JlbWVudCAhPT0gZmFsc2UgKSB7XHJcblx0XHRcdFx0aW5jcmVtZW50ID0gTnVtYmVyKGluY3JlbWVudC50b0ZpeGVkKHN0ZXBEZWNpbWFscykpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGRlY3JlbWVudCAhPT0gbnVsbCAmJiBkZWNyZW1lbnQgIT09IGZhbHNlICkge1xyXG5cdFx0XHRcdGRlY3JlbWVudCA9IE51bWJlcihkZWNyZW1lbnQudG9GaXhlZChzdGVwRGVjaW1hbHMpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIFtkZWNyZW1lbnQsIGluY3JlbWVudF07XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdC8vIEF0dGFjaCBhbiBldmVudCB0byB0aGlzIHNsaWRlciwgcG9zc2libHkgaW5jbHVkaW5nIGEgbmFtZXNwYWNlXHJcblx0ZnVuY3Rpb24gYmluZEV2ZW50ICggbmFtZXNwYWNlZEV2ZW50LCBjYWxsYmFjayApIHtcclxuXHRcdHNjb3BlX0V2ZW50c1tuYW1lc3BhY2VkRXZlbnRdID0gc2NvcGVfRXZlbnRzW25hbWVzcGFjZWRFdmVudF0gfHwgW107XHJcblx0XHRzY29wZV9FdmVudHNbbmFtZXNwYWNlZEV2ZW50XS5wdXNoKGNhbGxiYWNrKTtcclxuXHJcblx0XHQvLyBJZiB0aGUgZXZlbnQgYm91bmQgaXMgJ3VwZGF0ZSwnIGZpcmUgaXQgaW1tZWRpYXRlbHkgZm9yIGFsbCBoYW5kbGVzLlxyXG5cdFx0aWYgKCBuYW1lc3BhY2VkRXZlbnQuc3BsaXQoJy4nKVswXSA9PT0gJ3VwZGF0ZScgKSB7XHJcblx0XHRcdHNjb3BlX0hhbmRsZXMuZm9yRWFjaChmdW5jdGlvbihhLCBpbmRleCl7XHJcblx0XHRcdFx0ZmlyZUV2ZW50KCd1cGRhdGUnLCBpbmRleCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gVW5kbyBhdHRhY2htZW50IG9mIGV2ZW50XHJcblx0ZnVuY3Rpb24gcmVtb3ZlRXZlbnQgKCBuYW1lc3BhY2VkRXZlbnQgKSB7XHJcblxyXG5cdFx0dmFyIGV2ZW50ID0gbmFtZXNwYWNlZEV2ZW50ICYmIG5hbWVzcGFjZWRFdmVudC5zcGxpdCgnLicpWzBdO1xyXG5cdFx0dmFyIG5hbWVzcGFjZSA9IGV2ZW50ICYmIG5hbWVzcGFjZWRFdmVudC5zdWJzdHJpbmcoZXZlbnQubGVuZ3RoKTtcclxuXHJcblx0XHRPYmplY3Qua2V5cyhzY29wZV9FdmVudHMpLmZvckVhY2goZnVuY3Rpb24oIGJpbmQgKXtcclxuXHJcblx0XHRcdHZhciB0RXZlbnQgPSBiaW5kLnNwbGl0KCcuJylbMF0sXHJcblx0XHRcdFx0dE5hbWVzcGFjZSA9IGJpbmQuc3Vic3RyaW5nKHRFdmVudC5sZW5ndGgpO1xyXG5cclxuXHRcdFx0aWYgKCAoIWV2ZW50IHx8IGV2ZW50ID09PSB0RXZlbnQpICYmICghbmFtZXNwYWNlIHx8IG5hbWVzcGFjZSA9PT0gdE5hbWVzcGFjZSkgKSB7XHJcblx0XHRcdFx0ZGVsZXRlIHNjb3BlX0V2ZW50c1tiaW5kXTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHQvLyBVcGRhdGVhYmxlOiBtYXJnaW4sIGxpbWl0LCBwYWRkaW5nLCBzdGVwLCByYW5nZSwgYW5pbWF0ZSwgc25hcFxyXG5cdGZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMgKCBvcHRpb25zVG9VcGRhdGUsIGZpcmVTZXRFdmVudCApIHtcclxuXHJcblx0XHQvLyBTcGVjdHJ1bSBpcyBjcmVhdGVkIHVzaW5nIHRoZSByYW5nZSwgc25hcCwgZGlyZWN0aW9uIGFuZCBzdGVwIG9wdGlvbnMuXHJcblx0XHQvLyAnc25hcCcgYW5kICdzdGVwJyBjYW4gYmUgdXBkYXRlZCwgJ2RpcmVjdGlvbicgY2Fubm90LCBkdWUgdG8gZXZlbnQgYmluZGluZy5cclxuXHRcdC8vIElmICdzbmFwJyBhbmQgJ3N0ZXAnIGFyZSBub3QgcGFzc2VkLCB0aGV5IHNob3VsZCByZW1haW4gdW5jaGFuZ2VkLlxyXG5cdFx0dmFyIHYgPSB2YWx1ZUdldCgpO1xyXG5cclxuXHRcdHZhciB1cGRhdGVBYmxlID0gWydtYXJnaW4nLCAnbGltaXQnLCAncGFkZGluZycsICdyYW5nZScsICdhbmltYXRlJywgJ3NuYXAnLCAnc3RlcCcsICdmb3JtYXQnXTtcclxuXHJcblx0XHQvLyBPbmx5IGNoYW5nZSBvcHRpb25zIHRoYXQgd2UncmUgYWN0dWFsbHkgcGFzc2VkIHRvIHVwZGF0ZS5cclxuXHRcdHVwZGF0ZUFibGUuZm9yRWFjaChmdW5jdGlvbihuYW1lKXtcclxuXHRcdFx0aWYgKCBvcHRpb25zVG9VcGRhdGVbbmFtZV0gIT09IHVuZGVmaW5lZCApIHtcclxuXHRcdFx0XHRvcmlnaW5hbE9wdGlvbnNbbmFtZV0gPSBvcHRpb25zVG9VcGRhdGVbbmFtZV07XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdHZhciBuZXdPcHRpb25zID0gdGVzdE9wdGlvbnMob3JpZ2luYWxPcHRpb25zKTtcclxuXHJcblx0XHQvLyBMb2FkIG5ldyBvcHRpb25zIGludG8gdGhlIHNsaWRlciBzdGF0ZVxyXG5cdFx0dXBkYXRlQWJsZS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpe1xyXG5cdFx0XHRpZiAoIG9wdGlvbnNUb1VwZGF0ZVtuYW1lXSAhPT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHRcdG9wdGlvbnNbbmFtZV0gPSBuZXdPcHRpb25zW25hbWVdO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBTYXZlIGN1cnJlbnQgc3BlY3RydW0gZGlyZWN0aW9uIGFzIHRlc3RPcHRpb25zIGluIHRlc3RSYW5nZSBjYWxsXHJcblx0XHQvLyBkb2Vzbid0IHJlbHkgb24gY3VycmVudCBkaXJlY3Rpb25cclxuXHRcdG5ld09wdGlvbnMuc3BlY3RydW0uZGlyZWN0aW9uID0gc2NvcGVfU3BlY3RydW0uZGlyZWN0aW9uO1xyXG5cdFx0c2NvcGVfU3BlY3RydW0gPSBuZXdPcHRpb25zLnNwZWN0cnVtO1xyXG5cclxuXHRcdC8vIExpbWl0LCBtYXJnaW4gYW5kIHBhZGRpbmcgZGVwZW5kIG9uIHRoZSBzcGVjdHJ1bSBidXQgYXJlIHN0b3JlZCBvdXRzaWRlIG9mIGl0LiAoIzY3NylcclxuXHRcdG9wdGlvbnMubWFyZ2luID0gbmV3T3B0aW9ucy5tYXJnaW47XHJcblx0XHRvcHRpb25zLmxpbWl0ID0gbmV3T3B0aW9ucy5saW1pdDtcclxuXHRcdG9wdGlvbnMucGFkZGluZyA9IG5ld09wdGlvbnMucGFkZGluZztcclxuXHJcblx0XHQvLyBJbnZhbGlkYXRlIHRoZSBjdXJyZW50IHBvc2l0aW9uaW5nIHNvIHZhbHVlU2V0IGZvcmNlcyBhbiB1cGRhdGUuXHJcblx0XHRzY29wZV9Mb2NhdGlvbnMgPSBbXTtcclxuXHRcdHZhbHVlU2V0KG9wdGlvbnNUb1VwZGF0ZS5zdGFydCB8fCB2LCBmaXJlU2V0RXZlbnQpO1xyXG5cdH1cclxuXHJcblx0Ly8gVGhyb3cgYW4gZXJyb3IgaWYgdGhlIHNsaWRlciB3YXMgYWxyZWFkeSBpbml0aWFsaXplZC5cclxuXHRpZiAoIHNjb3BlX1RhcmdldC5ub1VpU2xpZGVyICkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiBTbGlkZXIgd2FzIGFscmVhZHkgaW5pdGlhbGl6ZWQuXCIpO1xyXG5cdH1cclxuXHJcblx0Ly8gQ3JlYXRlIHRoZSBiYXNlIGVsZW1lbnQsIGluaXRpYWxpc2UgSFRNTCBhbmQgc2V0IGNsYXNzZXMuXHJcblx0Ly8gQWRkIGhhbmRsZXMgYW5kIGNvbm5lY3QgZWxlbWVudHMuXHJcblx0YWRkU2xpZGVyKHNjb3BlX1RhcmdldCk7XHJcblx0YWRkRWxlbWVudHMob3B0aW9ucy5jb25uZWN0LCBzY29wZV9CYXNlKTtcclxuXHJcblx0c2NvcGVfU2VsZiA9IHtcclxuXHRcdGRlc3Ryb3k6IGRlc3Ryb3ksXHJcblx0XHRzdGVwczogZ2V0Q3VycmVudFN0ZXAsXHJcblx0XHRvbjogYmluZEV2ZW50LFxyXG5cdFx0b2ZmOiByZW1vdmVFdmVudCxcclxuXHRcdGdldDogdmFsdWVHZXQsXHJcblx0XHRzZXQ6IHZhbHVlU2V0LFxyXG5cdFx0cmVzZXQ6IHZhbHVlUmVzZXQsXHJcblx0XHQvLyBFeHBvc2VkIGZvciB1bml0IHRlc3RpbmcsIGRvbid0IHVzZSB0aGlzIGluIHlvdXIgYXBwbGljYXRpb24uXHJcblx0XHRfX21vdmVIYW5kbGVzOiBmdW5jdGlvbihhLCBiLCBjKSB7IG1vdmVIYW5kbGVzKGEsIGIsIHNjb3BlX0xvY2F0aW9ucywgYyk7IH0sXHJcblx0XHRvcHRpb25zOiBvcmlnaW5hbE9wdGlvbnMsIC8vIElzc3VlICM2MDAsICM2NzhcclxuXHRcdHVwZGF0ZU9wdGlvbnM6IHVwZGF0ZU9wdGlvbnMsXHJcblx0XHR0YXJnZXQ6IHNjb3BlX1RhcmdldCwgLy8gSXNzdWUgIzU5N1xyXG5cdFx0cGlwczogcGlwcyAvLyBJc3N1ZSAjNTk0XHJcblx0fTtcclxuXHJcblx0Ly8gQXR0YWNoIHVzZXIgZXZlbnRzLlxyXG5cdGJpbmRTbGlkZXJFdmVudHMob3B0aW9ucy5ldmVudHMpO1xyXG5cclxuXHQvLyBVc2UgdGhlIHB1YmxpYyB2YWx1ZSBtZXRob2QgdG8gc2V0IHRoZSBzdGFydCB2YWx1ZXMuXHJcblx0dmFsdWVTZXQob3B0aW9ucy5zdGFydCk7XHJcblxyXG5cdGlmICggb3B0aW9ucy5waXBzICkge1xyXG5cdFx0cGlwcyhvcHRpb25zLnBpcHMpO1xyXG5cdH1cclxuXHJcblx0aWYgKCBvcHRpb25zLnRvb2x0aXBzICkge1xyXG5cdFx0dG9vbHRpcHMoKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBzY29wZV9TZWxmO1xyXG5cclxufVxyXG5cclxuXHJcblx0Ly8gUnVuIHRoZSBzdGFuZGFyZCBpbml0aWFsaXplclxyXG5cdGZ1bmN0aW9uIGluaXRpYWxpemUgKCB0YXJnZXQsIG9yaWdpbmFsT3B0aW9ucyApIHtcclxuXHJcblx0XHRpZiAoICF0YXJnZXQubm9kZU5hbWUgKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogY3JlYXRlIHJlcXVpcmVzIGEgc2luZ2xlIGVsZW1lbnQuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRlc3QgdGhlIG9wdGlvbnMgYW5kIGNyZWF0ZSB0aGUgc2xpZGVyIGVudmlyb25tZW50O1xyXG5cdFx0dmFyIG9wdGlvbnMgPSB0ZXN0T3B0aW9ucyggb3JpZ2luYWxPcHRpb25zLCB0YXJnZXQgKTtcclxuXHRcdHZhciBhcGkgPSBjbG9zdXJlKCB0YXJnZXQsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucyApO1xyXG5cclxuXHRcdHRhcmdldC5ub1VpU2xpZGVyID0gYXBpO1xyXG5cclxuXHRcdHJldHVybiBhcGk7XHJcblx0fVxyXG5cclxuXHQvLyBVc2UgYW4gb2JqZWN0IGluc3RlYWQgb2YgYSBmdW5jdGlvbiBmb3IgZnV0dXJlIGV4cGFuc2liaWxpdHk7XHJcblx0cmV0dXJuIHtcclxuXHRcdHZlcnNpb246IFZFUlNJT04sXHJcblx0XHRjcmVhdGU6IGluaXRpYWxpemVcclxuXHR9O1xyXG5cclxufSkpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbm91aXNsaWRlci9kaXN0cmlidXRlL25vdWlzbGlkZXIuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n\nvar noUiSlider = __webpack_require__(3);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'nouislider',\n\n  props: {\n    config: {\n      type: Object,\n      required: true\n    },\n    values: {\n      type: Array,\n      required: true\n    },\n    id: {\n      type: String,\n      required: false\n    }\n  },\n\n  data: function data() {\n    return {\n      slider: null\n    };\n  },\n\n\n  methods: {\n    /**\n     * Update a slider handle value\n     * @param value\n     * @param handle\n     */\n    updateValue: function updateValue(value, handle) {\n      this.$set(this.values, handle, value[handle]);\n    },\n    /**\n     * Create a unique slider id\n     * @returns {string}\n     */\n    uniqueId: function uniqueId() {\n      function s4() {\n        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n      }\n      return 'vue-nouislider-' + s4() + s4();\n    }\n  },\n\n  computed: {\n    /**\n     * Set the slider ID with prop value or random ID\n     * @returns {string}\n     */\n    sliderId: function sliderId() {\n      if (this.id === undefined) {\n        return this.uniqueId();\n      }\n\n      return this.id;\n    }\n  },\n\n  mounted: function mounted() {\n    var _this = this;\n\n    this.slider = document.getElementById(this.sliderId);\n\n    this.config.start = this.values;\n\n    noUiSlider.create(this.slider, this.config);\n\n    this.slider.noUiSlider.on('update', this.updateValue);\n\n    // Listen for Event on parent component if values are changed\n    this.$parent.$on('updateValue', function (value) {\n      _this.slider.noUiSlider.set(value);\n    });\n\n    // Fire Event if new value is set with the slider\n    this.slider.noUiSlider.on('change', function (newValues) {\n      _this.$parent.$emit('newValueSet', newValues);\n    });\n\n    this.slider.noUiSlider.on('start', function () {\n      _this.$parent.$off('updateValue');\n    });\n\n    this.slider.noUiSlider.on('end', function () {\n      _this.$parent.$on('updateValue', function (value) {\n        _this.slider.noUiSlider.set(value);\n      });\n    });\n  }\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9VaVNsaWRlci52dWU/NmEzNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFRQTs7QUFFQTtRQUdBOzs7O1lBR0E7Z0JBRUE7QUFIQTs7WUFLQTtnQkFFQTtBQUhBOztZQUtBO2dCQUlBO0FBTEE7QUFUQTs7d0JBZUE7O2NBR0E7QUFGQTtBQUlBOzs7O0FBTUE7Ozs7O3FEQUNBOzJDQUNBO0FBQ0E7QUFJQTs7OztrQ0FDQTtvQkFDQTtnREFDQSxrQkFDQSxjQUNBO0FBQ0E7d0NBQ0E7QUFHQTtBQXRCQTs7O0FBMkJBOzs7O2tDQUNBO2lDQUNBO29CQUNBO0FBRUE7O2tCQUNBO0FBR0E7QUFiQTs7O0FBY0E7OytDQUVBOzs2QkFFQTs7d0NBRUE7OzZDQUVBOztBQUNBO3FEQUNBO2tDQUNBO0FBRUE7O0FBQ0E7NkRBQ0E7eUNBQ0E7QUFFQTs7bURBQ0E7eUJBQ0E7QUFFQTs7aURBQ0E7d0RBQ0E7b0NBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF6RkEiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cbiAgPGRpdj5cbiAgICA8ZGl2IGNsYXNzPVwidnVlLW5vdWlzbGlkZXJcIiA6aWQ9XCJzbGlkZXJJZFwiPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG4gIHZhciBub1VpU2xpZGVyID0gcmVxdWlyZSgnbm91aXNsaWRlcicpXG5cbiAgZXhwb3J0IGRlZmF1bHQge1xuICAgIG5hbWU6ICdub3Vpc2xpZGVyJyxcblxuICAgIHByb3BzOiB7XG4gICAgICBjb25maWc6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICB2YWx1ZXM6IHtcbiAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgfSxcbiAgICAgIGlkOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgfSxcbiAgICB9LFxuXG4gICAgZGF0YSAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzbGlkZXI6IG51bGwsXG4gICAgICB9XG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcbiAgICAgIC8qKlxuICAgICAgICogVXBkYXRlIGEgc2xpZGVyIGhhbmRsZSB2YWx1ZVxuICAgICAgICogQHBhcmFtIHZhbHVlXG4gICAgICAgKiBAcGFyYW0gaGFuZGxlXG4gICAgICAgKi9cbiAgICAgIHVwZGF0ZVZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGhhbmRsZSkge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy52YWx1ZXMsIGhhbmRsZSwgdmFsdWVbaGFuZGxlXSlcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZSBhIHVuaXF1ZSBzbGlkZXIgaWRcbiAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIHVuaXF1ZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIHM0ICgpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoMSArIE1hdGgucmFuZG9tKCkpICogMHgxMDAwMClcbiAgICAgICAgICAgIC50b1N0cmluZygxNilcbiAgICAgICAgICAgIC5zdWJzdHJpbmcoMSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ3Z1ZS1ub3Vpc2xpZGVyLScgKyBzNCgpICsgczQoKVxuICAgICAgfSxcbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2V0IHRoZSBzbGlkZXIgSUQgd2l0aCBwcm9wIHZhbHVlIG9yIHJhbmRvbSBJRFxuICAgICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgICAqL1xuICAgICAgc2xpZGVySWQgKCkge1xuICAgICAgICBpZiAodGhpcy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudW5pcXVlSWQoKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaWRcbiAgICAgIH0sXG4gICAgfSxcblxuICAgIG1vdW50ZWQgKCkge1xuICAgICAgdGhpcy5zbGlkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLnNsaWRlcklkKVxuXG4gICAgICB0aGlzLmNvbmZpZy5zdGFydCA9IHRoaXMudmFsdWVzXG5cbiAgICAgIG5vVWlTbGlkZXIuY3JlYXRlKHRoaXMuc2xpZGVyLCB0aGlzLmNvbmZpZylcblxuICAgICAgdGhpcy5zbGlkZXIubm9VaVNsaWRlci5vbigndXBkYXRlJywgdGhpcy51cGRhdGVWYWx1ZSlcblxuICAgICAgLy8gTGlzdGVuIGZvciBFdmVudCBvbiBwYXJlbnQgY29tcG9uZW50IGlmIHZhbHVlcyBhcmUgY2hhbmdlZFxuICAgICAgdGhpcy4kcGFyZW50LiRvbigndXBkYXRlVmFsdWUnLCAodmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy5zbGlkZXIubm9VaVNsaWRlci5zZXQodmFsdWUpXG4gICAgICB9KVxuXG4gICAgICAvLyBGaXJlIEV2ZW50IGlmIG5ldyB2YWx1ZSBpcyBzZXQgd2l0aCB0aGUgc2xpZGVyXG4gICAgICB0aGlzLnNsaWRlci5ub1VpU2xpZGVyLm9uKCdjaGFuZ2UnLCAobmV3VmFsdWVzKSA9PiB7XG4gICAgICAgIHRoaXMuJHBhcmVudC4kZW1pdCgnbmV3VmFsdWVTZXQnLCBuZXdWYWx1ZXMpXG4gICAgICB9KVxuXG4gICAgICB0aGlzLnNsaWRlci5ub1VpU2xpZGVyLm9uKCdzdGFydCcsICgpID0+IHtcbiAgICAgICAgdGhpcy4kcGFyZW50LiRvZmYoJ3VwZGF0ZVZhbHVlJylcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMuc2xpZGVyLm5vVWlTbGlkZXIub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgdGhpcy4kcGFyZW50LiRvbigndXBkYXRlVmFsdWUnLCAodmFsdWUpID0+IHtcbiAgICAgICAgICB0aGlzLnNsaWRlci5ub1VpU2xpZGVyLnNldCh2YWx1ZSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSxcbiAgfVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBzY29wZWQgbGFuZz1cInNjc3NcIj5cbiAgQGltcG9ydCAnfm5vdWlzbGlkZXIvZGlzdHJpYnV0ZS9ub3Vpc2xpZGVyLm1pbi5jc3MnO1xuPC9zdHlsZT5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub1VpU2xpZGVyLnZ1ZT84OTljM2U5ZSJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9ub1VpU2xpZGVyLnZ1ZT8xY2YzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcIm9taXRcIjowLFwicmVtb3ZlXCI6dHJ1ZX0hLi9+L2Nzcy1sb2FkZXIhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtZTkxZDM2MDBcIixcInNjb3BlZFwiOnRydWUsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9ub1VpU2xpZGVyLnZ1ZVxuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

eval("// this module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = Object.create(options.computed || null)\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n    options.computed = computed\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzP2Q0ZjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0aGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGVcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQgKFxuICByYXdTY3JpcHRFeHBvcnRzLFxuICBjb21waWxlZFRlbXBsYXRlLFxuICBzY29wZUlkLFxuICBjc3NNb2R1bGVzXG4pIHtcbiAgdmFyIGVzTW9kdWxlXG4gIHZhciBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVzTW9kdWxlID0gcmF3U2NyaXB0RXhwb3J0c1xuICAgIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gY29tcGlsZWRUZW1wbGF0ZS5yZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkXG4gIH1cblxuICAvLyBpbmplY3QgY3NzTW9kdWxlc1xuICBpZiAoY3NzTW9kdWxlcykge1xuICAgIHZhciBjb21wdXRlZCA9IE9iamVjdC5jcmVhdGUob3B0aW9ucy5jb21wdXRlZCB8fCBudWxsKVxuICAgIE9iamVjdC5rZXlzKGNzc01vZHVsZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIG1vZHVsZSA9IGNzc01vZHVsZXNba2V5XVxuICAgICAgY29tcHV0ZWRba2V5XSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vZHVsZSB9XG4gICAgfSlcbiAgICBvcHRpb25zLmNvbXB1dGVkID0gY29tcHV0ZWRcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXNNb2R1bGU6IGVzTW9kdWxlLFxuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', [_c('div', {\n    staticClass: \"vue-nouislider\",\n    attrs: {\n      \"id\": _vm.sliderId\n    }\n  })])\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-hot-reload-api\").rerender(\"data-v-e91d3600\", module.exports)\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9ub1VpU2xpZGVyLnZ1ZT9lY2VkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2JywgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwidnVlLW5vdWlzbGlkZXJcIixcbiAgICBhdHRyczoge1xuICAgICAgXCJpZFwiOiBfdm0uc2xpZGVySWRcbiAgICB9XG4gIH0pXSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtZTkxZDM2MDBcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi1lOTFkMzYwMFwifSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbm9VaVNsaWRlci52dWVcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ })
/******/ ]);
});